<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: PA | Algoogle]]></title>
  <link href="http://algoogle.hadrori.jp/categories/pa/atom.xml" rel="self"/>
  <link href="http://algoogle.hadrori.jp/"/>
  <updated>2015-12-14T02:08:05+09:00</updated>
  <id>http://algoogle.hadrori.jp/</id>
  <author>
    <name><![CDATA[hadrori]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PA 2010 Termites]]></title>
    <link href="http://algoogle.hadrori.jp/pa/pa2010termites/"/>
    <updated>2014-11-09T22:48:12+09:00</updated>
    <id>http://algoogle.hadrori.jp/pa/pa2010termites</id>
    <content type="html"><![CDATA[<p><a href="http://main.edu.pl/en/archive/pa/2010/ter">Termites</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>長さnの数列aがある.<br />
今, 0に隣接した正の数を0にかえてその分の値をスコアとして得る.<br />
これを2人で交互に繰り返す.<br />
どちらも最適な行動を取るとき得られるスコアの総和を2人分求めよ.</p>

<h4 id="section-1">解法</h4>

<hr />

<p>問題の操作はstackとdequeがいくつかあって, そのいずれかでpopしていくかんじ.<br />
以降stackは配列の右側がtopで, 単調増加とかは左から右に見た時のことを指しているとする.<br />
こういうゲームは自分が相手よりいくら勝っているかを考えると考えやすいことが多い.<br />
前処理として数字をうまくマージすることでgreedyに落とすことができる.</p>

<p>どういうときにgreedyでできるか考える.<br />
まずはdequeが1つの場合.<br />
列が単調であれば取る方は大きい方でよい.<br />
なぜなら偶数個であれば1個飛ばしで得られる列の大きいほうが得られ, 奇数個であればそれに一番小さい値が加わるだけだから.<br />
そのようなdequeが2つ以上の場合は？<br />
アクセス可能なところのうち大きい方から取ればよい.<br />
2つの場合を考えると最適な取り方は片方に単調性が崩れないようにもう片方を適当な位置に挿入したになるため.</p>

<p>もう少しdequeを詰める.<br />
dequeだけど大きい方しか見てないことと2つ以上あっても動き方は変わらない.<br />
つまりdeque内の列が谷型でもよいということ(使わない小さい方を潰す).<br />
列を谷型に直すのは単調に直すのより簡単(山になってる部分をマージする).</p>

<p>3つ並んだ数字x, y, zについて, {% m %}x \leq y, z \leq y{% em %}を満たすときを考える.<br />
この部分のxにアクセス可能なとき, これを取ると相手がyを取る.<br />
これだけでは損だけでつらいのでzを取る(xを取らざるを得なかった状況でも当然zを取ることになる).<br />
つまりxを取るとは相手よりx+y-zだけ多く得ると考えることができるので, x, y, zをx+y-zに置き換える.<br />
これは多重にやってもいい. なぜなら置き換えた後はただの1つの数字だから.<br />
また適用する順序は関係ない.<br />
なぜならv, w, x, y, zとあるとき(条件は今は無視する),<br />
v, w, xをマージするとv-w+x, y, zとなる. これをマージするとv-w+x-y+zとなる.<br />
x, y, zをマージするとv, w, x-y+zとなる. これをマージするとv-w+x-y+zとなる.<br />
w, x, yをマージするとv, w-x+y, zとなる. これをマージするとv-w+x-y+zとなる.</p>

<p>deque部分はこれでgreedyにできる！</p>

<p>stack部分は？<br />
山部分が潰せるのは同じ.<br />
それが単調非減少ならdequeの単調なものと同じ.<br />
谷の形は前半がdequeと同じ.<br />
つまりあとは単調減少になってる部分.</p>

<p>最後の2個x, y({% m %}x \geq y{% em %})を考える.<br />
片方がyを取ったとき, 相手はxを取るのが最善.<br />
なぜなら何もせずにx-yの差をつけることができるから.<br />
つまりどちらもこの最後の2個は他に取れるのがなくなるまで取らない.<br />
よって最初の個数の偶奇でどっちがとるか分かる(2個なので毎回同じ人が損する).<br />
もっと言うと初期の個数だけで決まるということは最初に取り除いて良い.<br />
これを繰り返すと単調減少になってる部分は消せる.</p>

<p>これであとはアクセス可能な部分の値でgreedyにできる.<br />
priority queueに突っ込んでやりましょう.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code PA/2010/termites.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PA 2011 Plotter]]></title>
    <link href="http://algoogle.hadrori.jp/pa/pa2011plotter/"/>
    <updated>2014-11-06T02:25:21+09:00</updated>
    <id>http://algoogle.hadrori.jp/pa/pa2011plotter</id>
    <content type="html"><![CDATA[<p><a href="http://main.edu.pl/en/archive/pa/2011/plo">Plotter</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>{% math %}</p>

<p>L_{1} = L<br />
\rightarrow _L_ \rightarrow LLR = L_{2}<br />
\rightarrow _L_L_R_ \rightarrow LLRLLRR = L_{3}\</p>

<p>{% endmath %}</p>

<p>というように, 次の列は前の列の文字の間にLとRを交互に挿入したもののn個目の列を考える.</p>

<p>原点から初めて(1,1)に線分を伸ばしたものを考える.<br />
そこからさっきの列を左からみていき, Lなら左に{% m %}sqrt{2}{% em %}進め, Rなら右に{% m %}sqrt{2}{% em %}進める.<br />
このときm個の座標について, その点を通る回数と通る時刻を列挙せよ</p>

<h4 id="section-1">解法</h4>

<hr />

<p>列は以下の様な定義に書き換えることができる.</p>

<p>{% math %}</p>

<p>L_{1} = L<br />
L_{i} = L_{i-1}Lr(L_{i})\</p>

<p>{% endmath %}</p>

<p>r()は文字列の順序を反転させ, さらにLとRを入れ替えたもの.<br />
また, {% m %}L_{i}{% em %}が終わった時点での位置は</p>

<p>{% math %}</p>

<p>x_{i} = x_{i-1}-y_{i-1}<br />
y_{i} = x_{i-1}+y_{i-1}\</p>

<p>{% endmath %}</p>

<p>nは2000ぐらいだが, クエリで来る座標が{% m %}10^{9}{% em %}程度なので終端点が大幅にはみ出たら適当に打ち切ればいい.</p>

<p>列の新しい定義から, 折れ線の最初と最後の2つに分けて再帰的にみれば線分上にある場合の端点からの距離がわかる.</p>

<p>{% math %}</p>

<p>d(x,y,n) = d(x,y,n-1) \cup {2^{n}-k: k\in d(y_{n}-y,x-x_{n},n-1)}</p>

<p>{% endmath %}</p>

<p>しかしこれでは{% m %}O(2^{n}){% em %}で死ぬので枝刈りを入れる.<br />
得られる折れ線を囲む四角形を考える. その外なら打ち切る.<br />
原点からの4辺までの距離(原点は四角形の内部であることに注意する)をr, t, l, bとする.</p>

<p>{% math %}</p>

<p>r_{1} = t_{1} = 1<br />
l_{1} = b_{1} = 0\</p>

<p>r_{i} = max(r_{i-1}, t_{i-1}+x_{i})<br />
t_{i} = max(t_{i-1}, l_{i-1}+y_{i})<br />
l_{i} = max(l_{i-1}, b_{i-1}-x_{i})<br />
b_{i} = max(b_{i-1}, r_{i-1}-y_{i})\</p>

<p>{% endmath %}</p>

<p>この枝刈りは根本的で, {% m %}O(n){% em %}まで削ることができる.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code PA/2011/Plotter.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PA 2010 Sweets]]></title>
    <link href="http://algoogle.hadrori.jp/pa/pa2010sweets/"/>
    <updated>2014-11-01T22:15:50+09:00</updated>
    <id>http://algoogle.hadrori.jp/pa/pa2010sweets</id>
    <content type="html"><![CDATA[<p><a href="http://main.edu.pl/en/archive/pa/2010/cuk">Sweets</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>n(&lt;=24)個の箱にそれぞれ{% m %}a_{i}{% em %}個のお菓子がある.<br />
これを3人兄弟Anton, Dmytro, Borysで箱ごとに配りたい.<br />
できるだけ平等に分けるとき最小のAntonとBorysのもらう数の差を求めよ.<br />
ただしそれぞれのもらう数A, D, Bは{% m %} A \geq D \geq B{% em %}を満たさなければならない.</p>

<h4 id="section-1">解法</h4>

<hr />

<p>まずn個の箱を半分ずつ({% m %}n_{0},n_{1}{% em %})に分ける.<br />
これは半分ずつ全列挙することで全体で全列挙するのを抑えるため.<br />
それぞれの集合で3人がもらう数を{% m %}A_{i}, D_{i}, B_{i}{% em %}とする.<br />
{% m %}(A_{i}, D_{i}, B_{i}){% em %}のありうる組を全列挙しておく.<br />
列挙した組の集合をそれぞれ{% m %}K_{0}, K_{1}{% em %}とする.</p>

<p>ここで以下のような変換{% m %}K_{i} \rightarrow K’_{i}{% em %}をする.</p>

<p>{% math %}</p>

<p>K_{0} \rightarrow K’<em>{0}<br />
(A</em>{0}, D_{0}, B_{0}) \in K_{0} \rightarrow (A_{0}-D_{0}, D_{0}-B_{0}) \in K’<em>{0}<br />
<br />
K</em>{1} \rightarrow K’<em>{1}<br />
(A</em>{1}, D_{1}, B_{1}) \in K_{1} \rightarrow (D_{1}-A_{1}, B_{1}-D_{1}) \in K’_{1}\</p>

<p>{% endmath %}</p>

<p>これによって求める最小値は{% m %}K’<em>{0}, K’</em>{1}{% em %}の要素{% m %}(x_{0},y_{0}), (x_{1},y_{1}){% em %}について</p>

<p>{% math %}</p>

<p>(x_{0}+y_{0})-(x_{1}+y_{1})</p>

<p>{% endmath %}</p>

<p>の最小値となる.<br />
ただし{% m %}x_{0}\geq x_{1}, y_{0}\geq y_{1}{% em %}を満たす組のみ.<br />
なぜなら</p>

<p>{% math %}</p>

<p>A_{0}+A_{1} \leq D_{0}+D_{1}<br />
A_{0}-D_{0} \leq D_{1}-A_{1}<br />
<br />
D_{0}+D_{1} \leq B_{0}+B_{1}<br />
D_{0}-B_{0} \leq B_{1}-D_{1}\</p>

<p>{% endmath %}</p>

<p>を満たさなければならないから.</p>

<p>この条件から2次元上の最近点(マンハッタン距離)を求めれば良い.<br />
条件より{% m %}K’<em>{0}{% em %}の点を固定してと考えると, 最も近い{% m %}K’</em>{1}{% em %}の条件を満たす点というのは<br />
それより左下にあるもののうち, x+yが最大になる点とわかる.<br />
これは2つの集合の点を混ぜてyの昇順に見ていけば<br />
{% m %}K’<em>{0}{% em %}の点pのとき, それまでに出てきた{% m %}K’</em>{1}{% em %}の点のうちx座標についてp以下にあって, x+yが最大に点が一番近い.<br />
{% m %}K’_{1}{% em %}の点pのとき, 登場済みリストに入れる. ただしx座標についてそれ以降の点でx+yの値ががp以下のものは選ばれることが無い(もしくはそれを選ぶ必要がない)ので予め削除する.</p>

<p>2つ目の操作から登場済みリストはxについて単調増加であり, またx+yについて単調非減少になる.<br />
これの性質を利用することで1つ目の操作はx座標についてp以下のもののうち一番近いものを2分探索で選べばよく, 2つ目の操作はx座標についてp以上かつx+yについてp以下の点の区間を2分探索で求め削除することができる.</p>

<p>計算量は列挙に{% m %}O(3^{n/2}) = O(\sqrt{3}^{n}){% em %}, 各操作に{% m %}O(\log \sqrt{3}^{n}){% em %}となる.<br />
よって全体では{% m %}O(\sqrt(3)^{n}n) = O(1.74^{n}){% em %}となりなんとか間に合う.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code PA/2010/sweets.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PA 2010 Mashrooms]]></title>
    <link href="http://algoogle.hadrori.jp/pa/pa2010mashrooms/"/>
    <updated>2014-10-30T23:25:53+09:00</updated>
    <id>http://algoogle.hadrori.jp/pa/pa2010mashrooms</id>
    <content type="html"><![CDATA[<p><a href="http://main.edu.pl/en/archive/pa/2010/grz">Mashrooms</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>きのこが生えてる場所がn個1列に並んでいる.<br />
各位置には{% m %}a_{i}{% em %}個のきのこが生えてる.<br />
きのこは収穫から2単位時間で再び生える.<br />
となりの場所にいくのに1単位時間かかるとき, 時間t以内に最大何個きのこを採れるか.<br />
開始地点は0番目, 終了はどこでも良い.</p>

<h4 id="section-1">解法</h4>

<hr />

<p>最適な動きをしているときに戻る場合というのを考える.<br />
戻る場所から進んできているので次も必ず進む.<br />
そこで前に戻っているので次も必ず戻る…<br />
と必ず2箇所でループするはず.</p>

<p>よってそれまでの合計を初めから順に見て各位置でそこからループした場合の合計値を出す.<br />
注意するのはn=1の場合そこに留まり続けるので2回に1回加算されるというのを初期値にしておくこと.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code PA/2010/mashrooms.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PA 2006 Travel Agency]]></title>
    <link href="http://algoogle.hadrori.jp/pa/pa2006travel/"/>
    <updated>2014-10-30T22:24:16+09:00</updated>
    <id>http://algoogle.hadrori.jp/pa/pa2006travel</id>
    <content type="html"><![CDATA[<p><a href="http://main.edu.pl/en/archive/pa/2006/biu">Travel Agency</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>n人の客がいる.<br />
この人達に旅行を手配するとそれぞれ{% m %}x_{i}{% em %}の利益をもたらす(負もある).<br />
またこれらの人はそれぞれ{% m %}k_{i}{% em %}人と関係があり, {% m %}a_{ij}{% em %}が旅行に行かない場合{% m %}b_{ij}{% em %}の不利益を出す.<br />
利益を最大にするような客の選び方を求めよ</p>

<h4 id="section-1">解法</h4>

<hr />

<p>この問題はテストケースをダウンロードして, テストケース番号に応じて埋め込んだ答えを吐くコードを提出しなければならないことに注意すること.<br />
コードはそのとき使ったコード全てを載せておく.</p>

<ul>
  <li>説明抜きの解法</li>
</ul>

<p>もたらす利益が非負であるものの総和が利益の上限.<br />
ここから減る利益を最小化したい.<br />
頂点sから利益が非負の客に利益をコストとする有向辺を張る.<br />
利益が負の客から頂点tに利益の絶対値をコストとする有向辺を張る.<br />
次に客iと関係がある{% m %}a_{ij}{% em %}に{% m %}b_{ij}{% em %}をコストとする有向辺を張る.<br />
構築したグラフのS-T最小カットが減る利益の最小値, 集合Sが選ぶ客の集合, 集合Tを選ばない客の集合となる.</p>

<p>最小カットは最大流を求めればよく, 最大流を求めた後に集合Sはsから容量が正の辺を辿っていける頂点が選ぶ客になる.</p>

<ul>
  <li>なぜうまくいくのか</li>
</ul>

<p>頂点sから伸びてるのは増える分だけ, また増える分は全て頂点sから伸びてる.<br />
つまりsから伸びてる辺をカットするとその先の頂点をTに入れるということなので利益がその分減る.<br />
頂点tに入る辺は不利益をもたらす客からの辺で, 不利益をもたらす客からの辺は全てtに伸びてる.<br />
この辺をカットするということはその客をSに入れるということなのでその利益がその分減る.<br />
その他の辺は利益が減る辺で, その辺をカットするということは前の頂点はSに, 後の頂点はTに含まれるということ.<br />
これはまさに問題の客同士の関係を表している.</p>

<p>どの辺を切っても利益が減ることを表していて, 頂点を2つの集合に分けるような最小のコストを求めることになる.<br />
つまり最小カットを求めるとよいということになる.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code PA/2006/travel.sh %}</p>

<p>{% include_code PA/2006/travel.cpp %}</p>

<p>{% include_code PA/2006/travel2.cpp %}</p>
]]></content>
  </entry>
  
</feed>
