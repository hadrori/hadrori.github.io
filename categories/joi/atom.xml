<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: JOI | Algoogle]]></title>
  <link href="http://algoogle.hadrori.jp/categories/joi/atom.xml" rel="self"/>
  <link href="http://algoogle.hadrori.jp/"/>
  <updated>2015-12-14T02:04:43+09:00</updated>
  <id>http://algoogle.hadrori.jp/</id>
  <author>
    <name><![CDATA[hadrori]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JOI 春合宿 2012 Copy and Paste]]></title>
    <link href="http://algoogle.hadrori.jp/joi/sc2012copy-and-paste/"/>
    <updated>2014-10-13T18:11:49+09:00</updated>
    <id>http://algoogle.hadrori.jp/joi/sc2012copy-and-paste</id>
    <content type="html"><![CDATA[<p><a href="http://joisc2012.contest.atcoder.jp/tasks/joisc2012_copypaste">Copy and Paste</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>文字列を[l,r)をコピーして, 場所kに挿入するというクエリがN(&lt;=1000000)回くる.<br />
ただし毎回長さがM(&lt;=1000000)を超える場合はそれ以降は切り捨てる.<br />
最終的に作られる文字列を答えよ</p>

<h4 id="section-1">解法</h4>

<hr />

<p>永続赤黒木を使ってやる.<br />
<a href="http://www.ioi-jp.org/camp/2012/2012-sp-tasks/2012-sp-day4-copypaste-slides.pdf">解説スライド</a><br />
メモリが足りなくなったら木を再構築する.<br />
木を構築するときは文字列を半分にして右と左でできた木をマージする.<br />
ノードを再利用するのでノードのメモリ確保にnewするのではなく, 予め配列で用意しておいてそれを割り当てる.<br />
この配列から溢れる前に再構築する.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code JOI/2012/copy-and-paste.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JOI 春合宿 2012 JOI Flag]]></title>
    <link href="http://algoogle.hadrori.jp/joi/sc2012joiflag/"/>
    <updated>2014-10-06T23:45:23+09:00</updated>
    <id>http://algoogle.hadrori.jp/joi/sc2012joiflag</id>
    <content type="html"><![CDATA[<p><a href="http://joisc2012.contest.atcoder.jp/tasks/joisc2012_joi_flag">JOI Flag</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>以下の操作で塗られる旗を考える.<br />
1辺が2^Kの正方形を4つの等しい大きさの正方形に分解する.<br />
そのうち3つはJ, O, Iを割り当てて埋める.<br />
残りの1つは再帰的に同じ操作を繰り返す.<br />
1マスしか残らなかったらJOIのいずれかを割り当てる.</p>

<p>今N箇所がJOIのいずれかで塗られている旗がある.<br />
上の操作をして旗をつくりたい.<br />
既に塗られているマスを別の文字に変えるのにはコスト1かかる.<br />
コストの最小はいくらか</p>

<h4 id="section-1">解法</h4>

<hr />

<p>再帰的に分解しながらやればよい.<br />
各エリアに何個J, O, Iがそれぞれあるかと, そのエリアをまた分割する場合の最小のコストを求めていけばその正方形に対する最小のコストが求められる.<br />
今回はある正方形に対して<br />
左下＜右下＜左上＜右上<br />
と再帰的に定義してソートしておくことで各個数をO(KlogN)程度で求めた.<br />
実行時間に余裕があったようで毎回O(N)でカウントしても良かったらしい(空間に対してNが小さいので枝刈りで大幅に削れる).<br />
なので以下は蛇足.</p>

<p>上の順番付けは2点を含む正方形のうち, 分割すると異なる正方形にそれぞれが属するような正方形を考えた.<br />
これは2点のx座標のビット列で異なるビットの最上位の値が分割された正方形の1辺の長さになるのでMSBを求めれば良い.<br />
y座標についても同様にやって大きい方を採用する.<br />
そのビットより上のビットは共通しているので立てたまま, 下のビットは0にしてやれば境界が求まる.<br />
この境界を元に上の大小関係を満たすように番号付けすれば2点の比較ができる.<br />
この順にならんでいればあとはupper_bound-lower_boundで個数が求まる</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code JOI/2012/joiflag.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JOI 春合宿 2012 Fish]]></title>
    <link href="http://algoogle.hadrori.jp/joi/sc2012fish/"/>
    <updated>2014-10-06T00:07:56+09:00</updated>
    <id>http://algoogle.hadrori.jp/joi/sc2012fish</id>
    <content type="html"><![CDATA[<p><a href="http://joisc2012.contest.atcoder.jp/tasks/joisc2012_fish">Fish</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>N匹の魚がいる.<br />
これらは赤, 青, 緑のいずれかの色になっている.<br />
魚は体長が自分の2倍以上ある魚に食べられてしまうので一緒にできない.<br />
一緒にできる魚の色の組合せを求めよ</p>

<h4 id="section-1">解法</h4>

<hr />

<p>setにalgorithmのlower_boundを使っていてTLE死した.</p>

<p>ある魚に対してそれより小さい魚のうち一緒にいられる魚を考える.<br />
この時赤がr匹, 青がb匹, 緑がg匹いるとするとその選び方は3辺の長さがr, b, gの直方体の内部の格子点の数に一致する(=3辺がr+1,b+1,g+1の直方体の体積).<br />
これは赤, 青, 緑の選ぶ数に対して頂点が選べることからわかる.<br />
この組は魚の体長をソートしておけばしゃくとり法する感じで求められる.</p>

<p>よってそのようなものを全て列挙して, 直方体を重ねあわせた体積を求める問題になる.<br />
上から下に積分していけば, 各イベント点(各直方体のてっぺん)で長方形の和をとっていくことで断面が求められる.<br />
各直方体は軸に接するように置いていると考えれば, 断面の長方形の和は各長方形の右上を保存しておけばよい.<br />
この点列は内部に含まれるものを除けば階段状になっているので, 長方形を追加するときにすぐ下の段(右の段)にくる長方形は2分探索で求められる.<br />
そこから1つずつ左に見ていき, 高さを積分していくことで増加分の面積を求める.<br />
すぐ上の段を見つけたら間に今作った新しい段に完全に含まれる段を取り除く.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code JOI/2012/fish.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JOI 春合宿 2012 Building 2]]></title>
    <link href="http://algoogle.hadrori.jp/joi/sc2012building2/"/>
    <updated>2014-10-05T02:39:30+09:00</updated>
    <id>http://algoogle.hadrori.jp/joi/sc2012building2</id>
    <content type="html"><![CDATA[<p><a href="http://joisc2012.contest.atcoder.jp/tasks/joisc2012_building2">Building 2</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>木の上で最長部分増加列の長さを求めよ.</p>

<h4 id="section-1">解法</h4>

<hr />

<p>木DP.</p>

<p>木上での最長部分増加列は以下の3つの場合に分けられる</p>

<ul>
  <li>
    <p>葉から根に向かう方向のパス</p>
  </li>
  <li>
    <p>根から葉に向かう方向のパス</p>
  </li>
  <li>
    <p>ある頂点で向きが逆になるパス</p>
  </li>
</ul>

<p>これらは根付き木で上る方向に最長部分増加列(LIS), 下る方向に最長部分減少列(LDS)を求めてやればよい.<br />
LDSは単純に高さを負にしてやれば簡単.<br />
ある頂点でそれ以下の部分木のLISとLDSを求めれば, その親では子の列をマージしてやればよい(ある長さをとれる最小の値を採用する).<br />
またその頂点で折れる場合についてはマージ前に試してやる.<br />
マージには<a href="http://topcoder.g.hatena.ne.jp/iwiwi/20131226/1388062106">データ構造をマージする一般的なテク</a>を用いること</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code JOI/2012/building2.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JOI 春合宿 2011 Orienteering]]></title>
    <link href="http://algoogle.hadrori.jp/joi/sc2011orienteering/"/>
    <updated>2014-10-03T01:03:17+09:00</updated>
    <id>http://algoogle.hadrori.jp/joi/sc2011orienteering</id>
    <content type="html"><![CDATA[<p><a href="http://joisc2011.contest.atcoder.jp/tasks/joisc2011_orienteering">Orienteering</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>始点1, 終点nで頂点1からどの頂点にも到達可能なDAGが与えられる.<br />
K個の頂点をチェックポイントとして指定する.<br />
2人であわせて全てのチェックポイントを通って始点から終点に向かうようなパスの最短距離を求めよ</p>

<h4 id="section-1">解法</h4>

<hr />

<p>まずどの頂点がどの頂点より前に来るか知りたいのでトポロジカルソートする.<br />
続いてチェックポイント以外で止まることに意味はないので, チェックポイントだけのグラフを考えて全点対最短路を求める.<br />
あとはどのように頂点を進んでいくか.</p>

<p>片方がどちらかより先行していて, かつその頂点までのトポロジカル順で前にあるチェックポイントは全て通っているとする.<br />
このときの頂点をそれぞれ順にv, uと置く. またその状態までの最短距離をdp[v][u]と置く.<br />
そうすると次に向かう頂点wはvのトポロジカル順で次のチェックポイントになる.<br />
wにはどちらが進んでも問題ないが先行する方を次のvにするということに注意する.</p>

<p>これに加えてどちらも先行しない, つまりどちらも同じ場所にいる場合も考える.<br />
これは先行する場合の遷移先と, 先行する場合の遷移元に同じ頂点にいる場合を付け加えるだけで良い.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code JOI/2011/orienteering.cpp %}</p>
]]></content>
  </entry>
  
</feed>
