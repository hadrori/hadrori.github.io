<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Codeforces | Algoogle]]></title>
  <link href="http://algoogle.hadrori.jp/categories/codeforces/atom.xml" rel="self"/>
  <link href="http://algoogle.hadrori.jp/"/>
  <updated>2015-07-30T15:13:28+09:00</updated>
  <id>http://algoogle.hadrori.jp/</id>
  <author>
    <name><![CDATA[hadrori]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Codeforces 461C Appleman and a Sheet of Paper]]></title>
    <link href="http://algoogle.hadrori.jp/codeforces/461c/"/>
    <updated>2014-08-27T15:10:34+09:00</updated>
    <id>http://algoogle.hadrori.jp/codeforces/461c</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/461/problem/C">Appleman and a Sheet of Paper</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>長さnの紙を折っていきたい. 以下のクエリを捌け</p>

<ul>
  <li>
    <p>紙の左端からpのところで左から右に折る</p>
  </li>
  <li>
    <p>紙の左端から[l,r]の部分の紙の重なっている長さの総和を求める</p>
  </li>
</ul>

<h4 id="section-1">解法</h4>

<hr />

<p>まず左から右に折るというのを, pが現在の長さの半分より大きいなら右から左におることにする.<br />
またその次からは右から左にpを見るようにして, 大きいpが来るたびにこの反転を繰り返す.<br />
これによって区間[0,n)で処理できるようになる.<br />
以下の機能を持つSegment Treeを実装することでクエリを捌ける.</p>

<ul>
  <li>区間の紙の重なっている量を持つ</li>
  <li>区間の紙の厚さが一様かどうかを持つ</li>
  <li>区間に一度に足された量を持つ</li>
  <li>区間に値xを足す</li>
  <li>区間[a,b)を区間[c,d)にひっくり返して足す</li>
  <li>区間の重なっている長さの総和を求める</li>
</ul>

<p>ひっくり返して足すときは, 区間が完全に含まれていてさらに厚さが一様ならその区間に対応する目的の区間にその厚さを足して, そうでないなら区間を分割していくのでよい.<br />
また更新するときに区間の一部だけ足されることがあったらその区間の厚さは一様ではなくなる.</p>

<p>実は更新はナイーブに行ってもよい.<br />
長さnが減っていくことを考えると更新回数は高々n回になる.<br />
このことを利用すると, 各地点での和をBITで持つことによって更新全体でO(n log n), 総和の計算にはそれぞれO(log n)で答えることができる.<br />
また実装も平易なものになる.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code Codeforces/461C.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces 425B Sereja and Table]]></title>
    <link href="http://algoogle.hadrori.jp/codeforces/425b/"/>
    <updated>2014-08-25T16:16:39+09:00</updated>
    <id>http://algoogle.hadrori.jp/codeforces/425b</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/425/problem/B">Sereja and Table</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>n*mの01のテーブルがある.<br />
このテーブルの連結な同じ値をつなげるとそれぞれが1つの長方形になるように値を変更したい(ただし長方形の内側に他の値が含まれてはいけない).<br />
k回変更ができるとき, 最小の変更回数を求めよ.</p>

<h4 id="section-1">解法</h4>

<hr />

<p>目的の状態は市松模様のようになる.<br />
これは縦と横それぞれ1本ずつ01の列を持てばそのxorで各位置は表現できることを意味する.<br />
よってその2本の列を求めることを考える.</p>

<p>縦の数列をy, 横の列をxとする.<br />
{% m %}n\leq k{% em %}のときkの制約からyを全探索する. 一度yを決めればxの各値はその列の反転回数の少なくなるほうを選ぶのが最適.<br />
n &gt; kのとき, すくなくとも1つの行で反転が起こらない. この行をxとしてyの各値を反転回数の少なくなるように求める.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code Codeforces/425B.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces 425A Sereja and Swaps]]></title>
    <link href="http://algoogle.hadrori.jp/codeforces/425a/"/>
    <updated>2014-08-25T01:43:11+09:00</updated>
    <id>http://algoogle.hadrori.jp/codeforces/425a</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/425/problem/A">Sereja and Swaps</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>長さnの数列aのうち連続する要素の和の最大値を考える.<br />
k回要素の位置をswapできるとき, 最大はいくらになるか.</p>

<h4 id="section-1">解法</h4>

<hr />

<p>足し合わせる区間を決めたとき, swapするのはその区間の小さいものとその区間の外の大きいもの.<br />
よって区間を全てみて, それぞれ外と中でpriority_queueをもってやるとよい.<br />
入れ替えるのは内側の最小値が外側の最大値より小さいときに起こることに注意する.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code Codeforces/425A.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces 444C DZY Loves Colors]]></title>
    <link href="http://algoogle.hadrori.jp/codeforces/444c/"/>
    <updated>2014-08-24T21:33:24+09:00</updated>
    <id>http://algoogle.hadrori.jp/codeforces/444c</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/444/problem/C">DZY Loves Colors</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>長さnの帯があり, それは最初位置iの色がiになっている.<br />
この帯のある場所の色をyからxに変えるとき, その位置の鮮やかさが|y-x|だけ増える.
以下のクエリを実装しろ</p>

<ol>
  <li>
    <p>区間[l,r]を色xにする</p>
  </li>
  <li>
    <p>区間[l,r]の鮮やかさの合計を答える</p>
  </li>
</ol>

<h4 id="section-1">解法</h4>

<hr />

<p>以下のようなSegment Treeで実装する.</p>

<ul>
  <li>区間に全体に一度に足された鮮やかさ合計値(add)をもつ</li>
  <li>区間で足された鮮やかさの合計(sum)をもつ</li>
  <li>区間の色がすべて同じときの区間の色(col)をもつ</li>
  <li>区間の色を更新する</li>
  <li>区間の鮮やかさの合計を答える</li>
</ul>

<p>区間[l,r)を色xに更新するのは以下のように行う.</p>

<ul>
  <li>現在の区間より上の区間で1色になっていたらその色を現在の区間の色にする</li>
  <li>現在の区間が更新後とすでに同じ色なら終了</li>
  <li>
    <p>現在の区間が完全に更新したい区間に含まれているなら</p>

    <ul>
      <li>現在の区間が1色ならその区間に目的の色との差を一気に足す</li>
      <li>そうでないならさらに区間を下る</li>
      <li>現在の区間の色をxにする</li>
    </ul>
  </li>
  <li>そうでないなら区間の色をｰ1(1色ではない)にして区間を下る</li>
  <li>最後にその区間で足された鮮やかさの合計をsumに追加する</li>
</ul>

<p>更新したい区間に完全に含まれているとき\&amp;\&amp;区間の色が1色のときの更新が下の区間に伝播しないのでそこは遅延評価っぽくしている.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code Codeforces/444C.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces 444B DZY Loves FFT]]></title>
    <link href="http://algoogle.hadrori.jp/codeforces/444b/"/>
    <updated>2014-08-23T16:45:52+09:00</updated>
    <id>http://algoogle.hadrori.jp/codeforces/444b</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/444/problem/B">DZY Loves FFT</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>a, b(aは1~nの順列, bはd個の1とn-d個の0の順列)があるとき</p>

<p>{% math %}</p>

<p>c_i = max{a_{j}b_{i-j} \mid j \leq i}</p>

<p>{% endmath %}
で表されるcの列を求めよ.</p>

<h4 id="section-1">解法</h4>

<hr />

<p>dが小さいとき, 1となるbの位置を列挙しておけばそれぞれの位置に対してaの値を見ればcをO(nd)で求められる.<br />
dが大きいとき, 各位置で1になる確率が高くなるのでaの値が大きいものから最大になる場所を埋めていけば良い.<br />
既に埋まっている場所を候補から除外しておけば各位置で1になる確率が高いことからどんどん候補が減っていくはず.<br />
bは擬似乱数によって生成されるので悪意ある入力は考慮しなくて良い.<br />
今回は候補をpriority_queueに入れて, 現在の値が出現しなくなる位置まで取り出してその位置で最大値になれるか確認するのと, なれない場合ははpriority_queueに戻すという操作で実装した.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code Codeforces/444B.cpp %}</p>
]]></content>
  </entry>
  
</feed>
