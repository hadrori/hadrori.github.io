<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: TopCoder | Algoogle]]></title>
  <link href="http://algoogle.hadrori.jp/categories/topcoder/atom.xml" rel="self"/>
  <link href="http://algoogle.hadrori.jp/"/>
  <updated>2015-07-30T15:13:28+09:00</updated>
  <id>http://algoogle.hadrori.jp/</id>
  <author>
    <name><![CDATA[hadrori]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM 607 Div1]]></title>
    <link href="http://algoogle.hadrori.jp/topcoder/607div1/"/>
    <updated>2014-05-24T14:15:02+09:00</updated>
    <id>http://algoogle.hadrori.jp/topcoder/607div1</id>
    <content type="html"><![CDATA[<h4 id="easy">Easy</h4>

<hr />

<p><a href="http://community.topcoder.com/stat?c=problem_statement&amp;pm=12964&amp;rd=15840">PalindromicSubstringsDiv1</a></p>

<p>回文は真ん中からよむといいらしい.<br />
dp[l][r] := l から r までのsubstringが回文である確率.<br />
S[l] == S[r] ならdp[l+1][r-1]の確率で回文<br />
どっちかだけ’?’なら dp[l+1][r-1] / 26 の確率で回文<br />
どっちも’?’なら dp[l+1][r-1] * 26 / 26^2の確率で回文<br />
それ以外では回文にならない<br />
あとはそれぞれのsubstringが回文になる期待値を足し合わせればいい</p>

<h4 id="section">コード</h4>

<hr />

<p>{% include_code topcoder/607div1easy.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM 618 Div1]]></title>
    <link href="http://algoogle.hadrori.jp/topcoder/618div1/"/>
    <updated>2014-05-24T14:01:49+09:00</updated>
    <id>http://algoogle.hadrori.jp/topcoder/618div1</id>
    <content type="html"><![CDATA[<h4 id="easy">Easy</h4>

<hr />

<p><a href="http://community.topcoder.com/stat?c=problem_statement&amp;pm=10541&amp;rd=15851">Family</a><br />
親同士に辺を張って交互に2色に塗るだけ. 矛盾したらImpossible.</p>

<h4 id="section">コード</h4>

<hr />

<p>{% include_code topcoder/618div1easy.cpp %}</p>

<h4 id="medium">Medium</h4>

<hr />

<p><a href="http://community.topcoder.com/stat?c=problem_statement&amp;pm=13111&amp;rd=15851">LongWordsDiv1</a><br />
使う文字を左からA, B, …とする. 答えは最後に並べ替えた分かければ良い.<br />
このとき作られる文字列は2パターンある.<br />
AaAとAaAbAというパターン(a, bはA以外で作られた文字列).<br />
1つ目は明らかにBC..CBにAをつけただけなので使う文字が1つ分少ない場合の数.<br />
2つ目もa, bで使われる文字数の組み合わせを全て回してやればよい.<br /></p>

<h4 id="section-1">コード</h4>

<hr />

<p>{% include_code topcoder/618div1medium.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM 619 Div1]]></title>
    <link href="http://algoogle.hadrori.jp/topcoder/619div1/"/>
    <updated>2014-05-05T23:29:21+09:00</updated>
    <id>http://algoogle.hadrori.jp/topcoder/619div1</id>
    <content type="html"><![CDATA[<h4 id="easy">Easy</h4>

<hr />

<h4 id="section">問題概要</h4>

<hr />

<p>石が2個以上ある山を1つ選んで, 他の山2つに分ける.<br />
これを2人で交互に繰り返してできなくなった方の負け.<br />
2人が最善をつくすとき先攻の勝敗を出せ.</p>

<h4 id="section-1">解法</h4>

<hr />

<p>まず初期状態で不可能な場合は負け.<br />
その他の場合, 毎ターン山は1つ減る.<br />
また1個以上石がある2つの山に1個以上の石が加えられるので, 次の人は山が3つ以上あれば必ず少なくとも2つの山は選択できるはず.<br />
よって負ける場合は山の数が残り2つになった時なので, 初期状態の山の数の偶奇で判断できる.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code topcoder/619div1easy.cpp %}</p>

]]></content>
  </entry>
  
</feed>
