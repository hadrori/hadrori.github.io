<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: POI | Algoogle]]></title>
  <link href="http://algoogle.hadrori.jp/categories/poi/atom.xml" rel="self"/>
  <link href="http://algoogle.hadrori.jp/"/>
  <updated>2015-12-14T02:08:05+09:00</updated>
  <id>http://algoogle.hadrori.jp/</id>
  <author>
    <name><![CDATA[hadrori]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[POI X Monkeys]]></title>
    <link href="http://algoogle.hadrori.jp/poi/poi10monkeys/"/>
    <updated>2014-11-04T16:50:20+09:00</updated>
    <id>http://algoogle.hadrori.jp/poi/poi10monkeys</id>
    <content type="html"><![CDATA[<p><a href="http://main.edu.pl/en/archive/oi/10/mal">Monkeys</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>n匹の猿がいて, 猿0は木にぶら下がっている.<br />
各猿は片手につき1匹まで他の猿のしっぽをつかむことができる.<br />
互いにつかみ合うことも可能.<br />
今, 時刻mまで各時刻のある1匹の猿のどちらかの手を離す情報が記録してある.<br />
当然手を離したら落ちてしまう猿がでてくる.<br />
各猿の落下する時刻を求めよ.<br />
落下しない場合は-1<br />
また, 猿ははじめ全員落下しないでぶら下がれている.</p>

<h4 id="section-1">解法</h4>

<hr />

<p>逆順に処理していけば良い.<br />
始めに時刻mからはじめる.<br />
このとき連結している猿同士を1つのグループとしてまとめて考える.<br />
これはUnion-Find木で管理すれば良い.<br />
また各グループにどの猿が属しているかの情報も持っておきたいので, 各グループの根の猿の番号をグループ番号として別個に猿の集合を持っておく.<br />
グループをマージするとき, どちらか一方のみが猿0と同じグループに属しているならもう片方のグループはその時刻に落ちたということがわかる.<br />
よってそのグループに属する猿の答えを記録し, マージする.<br />
Union-Findのマージはいいとして, 猿の集合のマージはデータ構造をマージする一般的なテクを使う(そうするとそのマージは全体でO(n)になる).</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code POI/X/monkeys.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[POI III Rooks]]></title>
    <link href="http://algoogle.hadrori.jp/poi/poi3rooks/"/>
    <updated>2014-11-03T15:37:46+09:00</updated>
    <id>http://algoogle.hadrori.jp/poi/poi3rooks</id>
    <content type="html"><![CDATA[<p><a href="http://main.edu.pl/en/archive/oi/3/wie">Rooks</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>n*nのチェス盤にルークをn個置く.<br />
ただし各ルークは他のルークから取れる位置に置かれない(Nクイーン問題の簡易版).<br />
今各ルークを置く位置の範囲を矩形で与えられる.<br />
それを満たすような置き方があるならそれを求めよ.<br />
存在しないならNIEと出せ</p>

<h4 id="section-1">解法</h4>

<hr />

<p>横と縦を分けて考えることができる.<br />
なぜならどの行, 列にもただひとつルークが存在するような置き方をし, 縦と横だけで区間が決まっているため.<br />
よって以下の操作を縦と横でやって合わせればよい.</p>

<p>位置iについて, そこから始まる区間の終端とidの組を候補リストに加える.<br />
もし位置iより右端が大きい候補が存在しなければ位置iに対応するルークが存在しないのでNIE<br />
存在するならそのうち右端が一番小さいルークを置く.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code POI/III/rooks.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[POI II The Coding of Permutations]]></title>
    <link href="http://algoogle.hadrori.jp/poi/poi2kod/"/>
    <updated>2014-11-02T13:03:25+09:00</updated>
    <id>http://algoogle.hadrori.jp/poi/poi2kod</id>
    <content type="html"><![CDATA[<p><a href="http://main.edu.pl/en/archive/oi/2/kod">The Coding of Permutations</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>1からnまでの整数を並び替えた数列をaとする.<br />
{% m %}b_{i}{% em %}をj&lt;iとなるjのうち{% m %}a_{j}{% em %}&gt;{% m %}a_{i}{% em %}となる数とする数列bが与えられる.<br />
数列aとして考えられるものを出力せよ. 存在しない場合はNIEと出せ.</p>

<h4 id="section-1">解法</h4>

<hr />

<p>数列を後ろから特定していく.<br />
値の候補の集合をSとし, i番目を見ているとき<br />
候補のうち{% m %}b_{i}{% em %}番目に大きい数を{% m %}a_{i}{% em %}とすればよい.<br />
その後候補から{% m %}a_{i}{% em %}を削除する.</p>

<p>あとは値の候補のうちk番目を見つけ, 削除できるようなデータ構造を考えれば良い.</p>

<p>今回はBITを使ってやることにした.<br />
簡単のため値は0からn-1で考える.<br />
値vを使ったら位置vに1を足す.<br />
すると位置jについてそれ以降に使われた値の個数というのがsum(j,n)でわかる.<br />
つまりj以降でまだ使われていない数はn-j-sum(j,n)個となる.<br />
あとは使われてない個数が{% m %}b_{i}+1{% em %}個になるような位置の最右端を二分探索すればよい.<br />
計算量は{% m %}O(n\log^{2}n){% em %}になる.</p>

<p>余談だが, 使ってないもののリストをvectorで持ち{% m %}b_{i}{% em %}番目を持ってきて削除とかはvectorのeraseが要素数の線形程度かかるので厳しい.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code POI/II/kod.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[POI XVII Pilots]]></title>
    <link href="http://algoogle.hadrori.jp/poi/poi17pilots/"/>
    <updated>2014-10-29T23:57:59+09:00</updated>
    <id>http://algoogle.hadrori.jp/poi/poi17pilots</id>
    <content type="html"><![CDATA[<p><a href="http://main.edu.pl/en/archive/oi/17/pil">Pilots</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>長さnの数列aの連続する部分列で最大値と最小値の差がt以下になるものの最大の長さを求めよ</p>

<h4 id="section-1">解法</h4>

<hr />

<p>Segment Treeでやるとlogがついて計算量的に厳しい.<br />
スライド最小値と最大値をしゃくとりしながらやる.<br />
最大値-最小値がt以下ならまだ伸ばせるかもしれないので1つ伸ばす.<br />
そうでないなら1つ縮める.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code POI/XVII/pilots.cpp %}</p>
]]></content>
  </entry>
  
</feed>
