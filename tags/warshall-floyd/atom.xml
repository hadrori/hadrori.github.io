<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: warshall-floyd | Algoogle]]></title>
  <link href="http://algoogle.hadrori.jp/tags/warshall-floyd/atom.xml" rel="self"/>
  <link href="http://algoogle.hadrori.jp/"/>
  <updated>2015-07-30T15:13:28+09:00</updated>
  <id>http://algoogle.hadrori.jp/</id>
  <author>
    <name><![CDATA[hadrori]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ 1182 Railway Connection]]></title>
    <link href="http://algoogle.hadrori.jp/aoj/1182/"/>
    <updated>2014-05-27T18:18:52+09:00</updated>
    <id>http://algoogle.hadrori.jp/aoj/1182</id>
    <content type="html"><![CDATA[<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1182">Railway Connection</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>駅と駅を繋ぐ路線には鉄道会社と距離が決まっている.<br />
各鉄道会社の距離に応じた運賃の計算方法が与えられるとき, 駅sから駅gまでの最小の運賃を求めよ.</p>

<h4 id="section-1">解法</h4>

<hr />

<p>鉄道会社ごとにwarshall-floydで駅から駅までの最短距離を求めておく.<br />
距離は高々20000なのでこれも予め鉄道会社ごとに距離に対する運賃を求めておく.<br />
あとは各駅間の最小の運賃をwarshall-floydで求めればよい.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code AOJ/1182.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ 2200 Mr. Rito Post Office]]></title>
    <link href="http://algoogle.hadrori.jp/aoj/2200/"/>
    <updated>2014-05-12T11:07:54+09:00</updated>
    <id>http://algoogle.hadrori.jp/aoj/2200</id>
    <content type="html"><![CDATA[<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2200">Mr. Rito Post Office</a></p>

<h4 id="section">問題概要</h4>

<hr />

<h4 id="section-1">解法</h4>

<hr />

<p>最初に陸路を使う場合のみと海路を使う場合のみのそれぞれの全点対最短路を求める.<br />
また, 入力では<br />
“ある2つの町や村を直接結ぶ陸路または海路が2本以上存在することがある”<br />
ので最小のものを選ぶ.</p>

<p>あとはDP<br />
dp[i][k] = dp[i-1][j] + 陸路[z[i-1]][j] + 海路[j][k] + 陸路[k][z[i]]<br />
また, j=kのときはそこに寄る必要はないのは明らかなのでそのときは<br />
dp[i][j] = dp[i-1][j] + 陸路[z[i-1]][z[i]]<br />
で求める.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code AOJ/2200.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PKU 3615 Cow Hurdles]]></title>
    <link href="http://algoogle.hadrori.jp/pku/3615/"/>
    <updated>2014-05-12T11:06:23+09:00</updated>
    <id>http://algoogle.hadrori.jp/pku/3615</id>
    <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=3615">Cow Hurdles</a></p>

<h4 id="section">問題概要</h4>

<hr />

<h4 id="section-1">解法</h4>

<hr />

<p>N &lt;= 300なのでWarshall-Floydで回します.<br />
T &lt;= 40000なので毎回Dijkstraとかすると間に合わないかもしれない.<br />
普通のグラフの問題と違って距離の和ではなく, 高さのmaxを取っていく.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code PKU/3615.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ 2549 7 Age]]></title>
    <link href="http://algoogle.hadrori.jp/aoj/2549/"/>
    <updated>2014-05-10T14:22:50+09:00</updated>
    <id>http://algoogle.hadrori.jp/aoj/2549</id>
    <content type="html"><![CDATA[<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2549">7 Age</a></p>

<h4 id="section">問題概要</h4>

<hr />

<h4 id="section-1">解法</h4>

<hr />

<p>各星間の最短路をワーシャルフロイドで出しておく.</p>

<p>ある星で布教するときは, その星の7歳である期間の最後までいるのが最もいいのは明らか.<br />
よって{% m %}r_j \geq r_i + w_{ij}{% em %}になる場合星iから星jに移動できると考える.<br />
またこの時, 星iから星jに移動した際の星jでの布教期間は<br />
{% m %}r_j - max(l_j, r_i + w_{ij}){% em %}<br />
となる.これを辺として, 星sから各星までの最長路を求めればいい.<br />
実装が楽そうだったのでワーシャルフロイドっぽくやりました.</p>

<p>注意するのは最初のどの星に行くかで, 最初に星jに行く場合の星jでの布教期間は<br />
{% m %}r_j - max(l_j, w_{sj}){% em %}<br />
になるので, これで初期化をしておく.<br />
また, まだ一度も訪れていない星をチェックする.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code AOJ/2549.cpp %}</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ 2567 SIRO Challenge]]></title>
    <link href="http://algoogle.hadrori.jp/aoj/2567/"/>
    <updated>2014-05-10T01:10:26+09:00</updated>
    <id>http://algoogle.hadrori.jp/aoj/2567</id>
    <content type="html"><![CDATA[<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2567">SIRO Challenge</a></p>

<h4 id="section">問題概要</h4>

<hr />

<h4 id="section-1">解法</h4>

<hr />

<p>ラーメン屋がある駅だけに注目すればいいのでWarshall-Floydでラーメン屋間の最短距離を求めておく.<br />
あとはTSPの全部回らなくてもいい場合みたいにbitDPする.<br />
dp[S][v] = すでに行ったラーメン屋の集合Sで, 最後に行った店がvの時の最小の経過時間<br />
dpの初期化はdp[0][s] = 0と各ラーメン屋iについてdp[1« i][s] = sとiの最短距離+食事時間<br />
あとはbitDPするだけ.<br />
結果は, 最後にsに行っていて, かつ時間がt以内であるSのうち, ビットが一番立ってる数をみればよい.<br />
最後に-1してるのは簡単にするためにsも食事時間0のラーメン屋にしているのでそれを省くため.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code AOJ/2567.cpp %}</p>

]]></content>
  </entry>
  
</feed>
