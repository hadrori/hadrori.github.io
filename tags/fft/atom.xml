<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: fft | Algoogle]]></title>
  <link href="http://algoogle.hadrori.jp/tags/fft/atom.xml" rel="self"/>
  <link href="http://algoogle.hadrori.jp/"/>
  <updated>2015-12-14T02:08:05+09:00</updated>
  <id>http://algoogle.hadrori.jp/</id>
  <author>
    <name><![CDATA[hadrori]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Codeforces 438E The Child and Binary Tree]]></title>
    <link href="http://algoogle.hadrori.jp/codeforces/438e/"/>
    <updated>2014-06-22T02:07:24+09:00</updated>
    <id>http://algoogle.hadrori.jp/codeforces/438e</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/problemset/problem/438/E">The Child and Binary Tree</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>2分木の各ノードに重みを割り当てるとき, 合計の重さ1〜mのそれぞれになりうる木の数を求めよ.<br />
ただし各重さは{% m %}{ c_1, c_2, …, c_n} {% em %}のいずれかで, 同じ重さは何度使っても良い.</p>

<h4 id="section-1">解法</h4>

<hr />

<p>FFTライブラリのverifyを兼ねて<a href="http://codeforces.com/blog/entry/12513">editorial</a>見ながら解いた.<br />
ある重さの木の場合の数は根の重さとその2つの子の重さの場合によって決定する.<br />
よって木の重さがwになる場合の数f[w]は,</p>

<p>{% math %}
    \begin{eqnarray<em>}
    f[0] &amp;=&amp; 1<br />
    f[w] &amp;=&amp; \sum_{i=1}^{n} \sum_{j=0}^{w-c_i} f[j]</em>f[w-c_i-j]<br />
    \end{eqnarray*}
{% endmath %}</p>

<p>と表せる. またここで次数を重さとみた多項式を考えると</p>

<p>{% math %}
    \begin{eqnarray<em>}
    F(z) &amp;=&amp; \sum_{k\geq 0} f[k]z^{k}<br />
    C(z) &amp;=&amp; \sum_{k=1}^{n} z^{c_k}<br />
    \end{eqnarray</em>}
{% endmath %}</p>

<p>1つ目は答えを係数に持つ多項式, 2つ目は使える重さの多項式が考えられる.<br />
ある重さの木の場合の数の条件からこの2つの多項式は以下の関係を持つことがわかる.</p>

<p>{% math %}
    \begin{eqnarray<em>}
    F(z) &amp;=&amp; C(z)F(z)^2+1
    \end{eqnarray</em>}
{% endmath %}</p>

<p>これを解くと</p>

<p>{% math %}
    \begin{eqnarray<em>}
    F(z) &amp;=&amp; \frac{2}{1+\sqrt{1-4C(z)}}
    \end{eqnarray</em>}
{% endmath %}</p>

<p>となる. もう片方の解はf[0]が1であることを考えるとありえないことがわかる({% m %} C(z)=2z-4z^{2} {% em %} などを考えてみるとよい).</p>

<p>あとはこれを実装すればよい. 多項式の平方根は</p>

<p>{% math %}
    \begin{eqnarray<em>}
    S_n(z)^2 \equiv F(z) &amp;&amp; (mod \ z^n)
    \end{eqnarray</em>}
{% endmath %}</p>

<p>とすると</p>

<p>{% math %}
    \begin{eqnarray<em>}
    S_{2n}(z) \equiv (S_n(z)+ F(z)S_n(z)^{-1})/2 &amp;&amp; (mod \ z^{2n})
    \end{eqnarray</em>}
{% endmath %}</p>

<p>となるので順に計算すればよい.<br />
あとは多項式の積をFFT(modの制約から剰余環を使ったものがよい)を用いて計算すること.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code Codeforces/438E.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces 286E Ladies' Shop]]></title>
    <link href="http://algoogle.hadrori.jp/codeforces/286e/"/>
    <updated>2014-06-19T00:00:29+09:00</updated>
    <id>http://algoogle.hadrori.jp/codeforces/286e</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/problemset/problem/286/E">Ladies’ Shop</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>それぞれ重さがa<a href="&lt;=m">i</a>のn個のバッグがある. 今そのバッグに入れる品物の種類を以下のように決めたい.</p>

<ul>
  <li>全てのバッグに対して, ちょうど重さの和がそのバッグの重さと等しくなるように品物をとってこれる. ただし選ぶ品物は何種類でもよくて, さらにそれぞれの種類を複数持ってくることもできる.</li>
  <li>重さの総和が1以上m以下になるように品物を任意種類, 任意個取ってくるとその重さの総和は必ずいずれかのバッグの重さと必ず一致する.</li>
  <li>これらを満たすときの品物の種類の数が最小になるもの</li>
</ul>

<h4 id="section-1">解法</h4>

<hr />

<p>重さを次数とした多項式fを考える. fの各項の係数をその項の次数のバッグの重さが存在するかどうかとする.<br />
このfを2乗すると, 各係数はバッグの重さから重複を許してちょうど2個選んだときの各重さの順列になる.<br />
なんとなく例としてサンプル1でみてみる.</p>

<p><code>
weight: 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
f     : 0  0  0  0  0  1  1  1  1  1  1  0  0  0  0  0  0  0  0  0  0
f^2   : 0  0  0  0  0  0  0  0  0  0  1  2  3  4  5  6  5  4  3  2  1
</code></p>

<p>このf^2より, 品物を2個選んだときにできる重さがわかるのでfと比較して答えを出せる.</p>

<p>以降はm以下の重さについて</p>

<p>fにあって, f^2にない品物について<br />
3個以上選んでもその重さは明らかに存在し得ない.<br />
よって条件から必ず必要.</p>

<p>f^2にあってfにない品物について<br />
条件を満たさないので明らかにNO.<br />
3個以上とか関係ない.</p>

<p>どちらにもある場合はその品物を選ぶ必要はない(それ以下の重さで作れるということなので)</p>

<p>どちらにもない場合について<br />
バッグの重さの最大の2倍までは1個でも2個で作れないならどうやっても作ることが出来ないので無視<br />
2倍より大きい場合, 最低でも3個使っていて, 2個では作れない数になっている.<br />
2個では作れないので, それらを2つの塊に分けたら少なくともどちらかのの重さの和はバッグの重さの最大を超えているはず.<br />
そのような場合は条件から除外されなければならず, その除外は現在の重さより前に行われる.<br />
よってこの場合も無視してよい.</p>

<p>以上から答えの集合はfにあってf^2にないものが必要十分であるとわかり, そのような集合の要素は上でNOでないなら必ず1つ以上存在する.<br />
重さが最大で10^6あり愚直に積を求めるとO(N^2)でTLEするので, FFTでO(NlogN)に落として計算することにする.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code Codeforces/286E.cpp %}</p>
]]></content>
  </entry>
  
</feed>
