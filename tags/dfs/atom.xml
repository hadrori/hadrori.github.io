<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: dfs | Algoogle]]></title>
  <link href="http://algoogle.hadrori.jp/tags/dfs/atom.xml" rel="self"/>
  <link href="http://algoogle.hadrori.jp/"/>
  <updated>2015-12-14T02:08:05+09:00</updated>
  <id>http://algoogle.hadrori.jp/</id>
  <author>
    <name><![CDATA[hadrori]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Codeforces 382D Ksenia and Pawns]]></title>
    <link href="http://algoogle.hadrori.jp/codeforces/382d/"/>
    <updated>2014-07-09T23:48:22+09:00</updated>
    <id>http://algoogle.hadrori.jp/codeforces/382d</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/382/problem/D">Ksenia and Pawns</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>盤上に向きが指定されているマスがある.<br />
コマを2つ置いてそのマスの指示通りに動かす(何も書かれていないマスで止まる).<br />
向きが指定されているマスには同時に2つのコマは置けず, そうでないマスには置ける.<br />
移動後に同時に2コマ存在することになる場合はそこで終了.<br />
2つのコマの位置を決めるとき, 動く回数の総和を最大はいくらになるか. 無限に移動できる場合は-1を出力しろ</p>

<h4 id="section-1">解法</h4>

<hr />

<p>移動のルートは無限ループを除いて, &#8216;#&#8217;を根とする木になっている.<br />
根には2つのコマがきてもいいので, その子の部分木を考える.<br />
各部分木の高さhを求めれば最長距離がわかり, その木に2つ置く場合はh-1が2番目に長い距離になる(高さhが2つ以上存在する場合でもそれは途中でぶつかる).<br />
あとはこれを全ての&#8217;#&#8217;を根とする木について調べて高さの最大2つを取ってくれば良い.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code Codeforces/382D.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces 430C Xor-tree]]></title>
    <link href="http://algoogle.hadrori.jp/codeforces/430c/"/>
    <updated>2014-07-04T17:01:35+09:00</updated>
    <id>http://algoogle.hadrori.jp/codeforces/430c</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/problemset/problem/430/C">Xor-tree</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>頂点数nの根付き木の各頂点は0か1の値をとる.<br />
ある頂点xを選んで値を反転させたら, その孫, 孫の孫, …の頂点も反転させる.<br />
初期状態と目的状態があるとき最小の選択回数と, 選択する頂点を答えよ.</p>

<h4 id="section-1">解法</h4>

<hr />

<p>根付き木なので根から順に見ていけばそこを反転するかどうかは一意に決まる.<br />
dfsするときに1つおきの祖先の反転情報を2つもって, 交互に使えばよい.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code Codeforces/430C.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Project Euler 206 Concealed Square]]></title>
    <link href="http://algoogle.hadrori.jp/projecteuler/206/"/>
    <updated>2014-05-30T00:44:24+09:00</updated>
    <id>http://algoogle.hadrori.jp/projecteuler/206</id>
    <content type="html"><![CDATA[<p><a href="http://projecteuler.net/problem=206">Concealed Square</a></p>

<h4 id="section">問題概要</h4>

<hr />

<h4 id="section-1">解法</h4>

<hr />

<p>全探索. 実行時間50秒だったのでよしとします.<br />
2乗して1の位が0になる場合は10の位も0で確定されるのは明らかなのでこれは埋めておく.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code PE/206.d %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PKU 2386 Lake Counting]]></title>
    <link href="http://algoogle.hadrori.jp/pku/2386/"/>
    <updated>2014-05-25T23:54:18+09:00</updated>
    <id>http://algoogle.hadrori.jp/pku/2386</id>
    <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=2386">Lake Counting</a></p>

<h4 id="section">問題概要</h4>

<hr />

<h4 id="section-1">解法</h4>

<hr />

<p>‘W’を見つけたら連結してるのをすべて’.’に変える.<br />
その回数を数える.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code PKU/2386.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PKU 3620 Avoid The Lakes]]></title>
    <link href="http://algoogle.hadrori.jp/pku/3620/"/>
    <updated>2014-05-25T23:46:10+09:00</updated>
    <id>http://algoogle.hadrori.jp/pku/3620</id>
    <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=3620">Avoid The Lakes</a></p>

<h4 id="section">問題概要</h4>

<hr />

<h4 id="section-1">解法</h4>

<hr />

<p>連結している個数をそれぞれdfsで数える.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code PKU/3620.cpp %}</p>
]]></content>
  </entry>
  
</feed>
