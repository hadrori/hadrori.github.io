<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: grundy-number | Algoogle]]></title>
  <link href="http://algoogle.hadrori.jp/tags/grundy-number/atom.xml" rel="self"/>
  <link href="http://algoogle.hadrori.jp/"/>
  <updated>2015-07-30T15:13:28+09:00</updated>
  <id>http://algoogle.hadrori.jp/</id>
  <author>
    <name><![CDATA[hadrori]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PKU 2975 Nim]]></title>
    <link href="http://algoogle.hadrori.jp/pku/2975/"/>
    <updated>2014-05-04T17:26:47+09:00</updated>
    <id>http://algoogle.hadrori.jp/pku/2975</id>
    <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=2975">Nim</a></p>

<h4 id="section">問題概要</h4>

<hr />

<h4 id="section-1">解法</h4>

<hr />

<p>必ず勝てるようになる1手目の数を返す.<br />
Nimはxorとって0以外だったら必勝.<br />
その場合の石の取り方は石をとった後にxorをすべて取ると0になるようにとる.<br />
そのように取れる山は1が立っているビットのうち最上位のビットがxor取った値の1が立ってる最上位のビットと同じ位置でなくてはいけない.<br />
またそのようなとき, 取り方は必ず1つだけある.<br />
よってそのような山の数を数えれば良い.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code PKU/2975.cpp %}</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Project Euler 301 Nim]]></title>
    <link href="http://algoogle.hadrori.jp/projecteuler/301/"/>
    <updated>2014-05-04T17:14:29+09:00</updated>
    <id>http://algoogle.hadrori.jp/projecteuler/301</id>
    <content type="html"><![CDATA[<p><a href="http://projecteuler.net/problem=301">Nim</a></p>

<h4 id="section">問題概要</h4>

<hr />

<h4 id="section-1">解法</h4>

<hr />

<p>Nimなので3つのxorとって0以外だったらカウント</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code PE/301.d %}</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ 2339 Person responsible for problem description don't w]]></title>
    <link href="http://algoogle.hadrori.jp/aoj/2339/"/>
    <updated>2014-05-04T17:09:25+09:00</updated>
    <id>http://algoogle.hadrori.jp/aoj/2339</id>
    <content type="html"><![CDATA[<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2339">Person responsible for problem description don’t w</a></p>

<h4 id="section">問題概要</h4>

<hr />

<h4 id="section-1">解法</h4>

<hr />

<p>閉路がないので必ず端の点は単調非増加. その点が0になったらその前の点が単調非増加になる.<br />
よって必ずすべての石は取ることが出来て, 引き分けは存在しない.</p>

<p>各点について, その先の点の石の数は自由に変化させられる.<br />
サンプルの1を例に取って考えてみる.<br />
1番の山から石をとる時, 2番の山の石の数は自由に変化できる.<br />
このとき, 2番の山を必ず0にすれば2番の山は無視でき, 同様に考えて1, 3, 5の独立した山だと考えることができる.<br />
相手によって2番の山を増やされて, 1番の山がなくなった場合は, 2番の山を全てとって3番の山を減らしたい数だけ減らせば良い.<br />
<img src="/images/aoj2339-01.png" alt="aoj2339-01" />
同様に, 2番めの山を取ってやりたいときは1番目の山をすべて取って, 2番めを減らしたい数だけ減らす. 1番目がないなら直接とって, 3番目は0にする. みたいに繰り返せる.<br />
このことからサンプル1では<br />
{1, 3, 5}, {2, 4, 6}<br />
の2つ山の集合それぞれについて分けてそれぞれのNimを考えれば良い. どちらを選択するかは先手が自由に決められるのでどちらかに必勝な場合があれば先手の勝ち.<br />
なお, 目的の山を相手に増やされた場合は同じ数だけ減らしてやれば打ち消せるので無視出来る.</p>

<p>もうすこし複雑な場合について考える.<br />
サンプル1に新たに7番目の点を追加して, 5と6に有向辺を張った場合, その山は上のどちらの集合の山にもアクセスできる.<br />
7番の山をすべてとって, 5番と6番を変化させて上のどちらの集合でも勝てるようにすれば必ず勝てるようになることが分かる.(つまり次の手が負けパターンになるようにする. )<br />
また新たに8番目の山を4, 5の山に辺を張るように考えると, これも7番と同じように考えられるが7番が残っている. これは7, 8だけで考えた時に最後に石をとる時, 先の山をいじるようにすればよい.<br />
よって{7, 8} を独立でかんがえた場合のの勝敗と全体の勝敗が一致する.<br />
これを繰り返すことで, 様々な場合で勝敗が決められるようになる.</p>

<p>あとは集合の分け方さえちゃんと決まればいい.<br />
ある点が属する集合は有向辺の先の集合と同じではいけないことは上から明らか.<br />
もっと言うと, 辺の先の集合に非負の番号をつけておくと, それら以外の最小の非負整数がその点の属する集合の番号になる.(ちょっと考えれば上の考察からわかるはず)</p>

<p>ということで, 再帰でその点の番号を出して, 同じ番号同士でそれぞれNimを考えて, 勝ちパターンが一つでもあれば勝ち, それ以外は負け. としてやればよい.<br />
Nimはxorとるだけ.</p>

<p>ちなみに, 集合の番号決めはgrundy数を決定するのとほぼおなじと考えられるので, grundy数について理解してからやると割りと自然にこの考察に行き着く.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code AOJ/2339.cpp %}</p>

]]></content>
  </entry>
  
</feed>
