<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: binary-indexed-tree | Algoogle]]></title>
  <link href="http://algoogle.hadrori.jp/tags/binary-indexed-tree/atom.xml" rel="self"/>
  <link href="http://algoogle.hadrori.jp/"/>
  <updated>2015-12-14T02:08:05+09:00</updated>
  <id>http://algoogle.hadrori.jp/</id>
  <author>
    <name><![CDATA[hadrori]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ 1083 The Incubator]]></title>
    <link href="http://algoogle.hadrori.jp/aoj/1083/"/>
    <updated>2015-10-18T16:26:37+09:00</updated>
    <id>http://algoogle.hadrori.jp/aoj/1083</id>
    <content type="html"><![CDATA[<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1083">The Incubator</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>以下のクエリをQ個を捌く</p>

<ul>
  <li>新しい個体に番号xを割り当てて列の末尾に入れる</li>
  <li>列のx番目の個体を列から取り除く</li>
  <li>列のx番目の個体番号を出力する</li>
  <li>番号xの個体を列から取り除く</li>
</ul>

<h4 id="section-1">解法</h4>

<hr />

<p>BITで列に入っているかを管理する．<br />
削除はその位置に-1, 追加は末尾に1を加える．<br />
1が立っている位置のうち左からx番目というのは2分探索すれば求まる．<br />
番号xの位置はmapで持って，位置yの番号は配列で持てば良い．</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code AOJ/1083.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[POI II The Coding of Permutations]]></title>
    <link href="http://algoogle.hadrori.jp/poi/poi2kod/"/>
    <updated>2014-11-02T13:03:25+09:00</updated>
    <id>http://algoogle.hadrori.jp/poi/poi2kod</id>
    <content type="html"><![CDATA[<p><a href="http://main.edu.pl/en/archive/oi/2/kod">The Coding of Permutations</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>1からnまでの整数を並び替えた数列をaとする.<br />
{% m %}b_{i}{% em %}をj&lt;iとなるjのうち{% m %}a_{j}{% em %}&gt;{% m %}a_{i}{% em %}となる数とする数列bが与えられる.<br />
数列aとして考えられるものを出力せよ. 存在しない場合はNIEと出せ.</p>

<h4 id="section-1">解法</h4>

<hr />

<p>数列を後ろから特定していく.<br />
値の候補の集合をSとし, i番目を見ているとき<br />
候補のうち{% m %}b_{i}{% em %}番目に大きい数を{% m %}a_{i}{% em %}とすればよい.<br />
その後候補から{% m %}a_{i}{% em %}を削除する.</p>

<p>あとは値の候補のうちk番目を見つけ, 削除できるようなデータ構造を考えれば良い.</p>

<p>今回はBITを使ってやることにした.<br />
簡単のため値は0からn-1で考える.<br />
値vを使ったら位置vに1を足す.<br />
すると位置jについてそれ以降に使われた値の個数というのがsum(j,n)でわかる.<br />
つまりj以降でまだ使われていない数はn-j-sum(j,n)個となる.<br />
あとは使われてない個数が{% m %}b_{i}+1{% em %}個になるような位置の最右端を二分探索すればよい.<br />
計算量は{% m %}O(n\log^{2}n){% em %}になる.</p>

<p>余談だが, 使ってないもののリストをvectorで持ち{% m %}b_{i}{% em %}番目を持ってきて削除とかはvectorのeraseが要素数の線形程度かかるので厳しい.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code POI/II/kod.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JOI 春合宿 2011 Report]]></title>
    <link href="http://algoogle.hadrori.jp/joi/sc2011report/"/>
    <updated>2014-09-28T23:00:42+09:00</updated>
    <id>http://algoogle.hadrori.jp/joi/sc2011report</id>
    <content type="html"><![CDATA[<p><a href="http://joisc2011.contest.atcoder.jp/tasks/joisc2011_report">Report</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>N個の人がいる, 各人はその番号より小さい番号の人の仕事が終わってから始める.<br />
またそれぞれ仕事の報告をする相手が決まっている.<br />
報告を受けたらさらにその報告を回す.<br />
また2回以上報告を受ける場合は2回目以降は無視する.<br />
それぞれの人が仕事の開始時までに受ける報告の仕事の数を求めよ.</p>

<h4 id="section-1">解法</h4>

<hr />

<p>閉路が存在する場合, その閉路内で報告が回せるので1つ塊としてみて良い.<br />
そこで閉路を強連結成分分解して潰す.<br />
そうすると複数の木ができるので各木で根からオイラーツアーして頂点に入るときと出るときに番号をふる.<br />
あとは各人が属する強連結成分について, そこに入ってから出るまでの部分木内で発生した報告の総数を求める.<br />
これはオイラーツアーしで振った番号で区間になるのでBITで管理すれば良い.<br />
仕事が完了したらその強連結成分に入るときの位置に1足せばその強連結成分内で発生した報告のカウントが出来る.</p>

<p>####</p>

<hr />

<p>{% include_code JOI/2011/report.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JOI 春合宿 2010 Highway]]></title>
    <link href="http://algoogle.hadrori.jp/joi/sc2010highway/"/>
    <updated>2014-09-19T22:36:03+09:00</updated>
    <id>http://algoogle.hadrori.jp/joi/sc2010highway</id>
    <content type="html"><![CDATA[<p><a href="http://joisc2010.contest.atcoder.jp/tasks/joisc2010_highway">Highway</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>木が与えられる.<br />
ノードの番号が小さい方から大きい方へいく時を上りといい, 逆の時を下りという.<br />
以下のクエリを処理しろ.</p>

<ul>
  <li>ある辺の上りと下りにかかる時間の変更</li>
  <li>ある2頂点x, yのxからyにいくときにかかる時間の総和の出力</li>
</ul>

<h4 id="section-1">解法</h4>

<hr />

<p>根付き木として考える.<br />
頂点uから頂点vまでの距離を求めたい.<br />
上りと下りの区別がないとして考える.<br />
上りと下りの区別がないとき, 2頂点間の距離はその最小共通祖先wまでの距離の和と考えるとよい.<br />
こうするとオイラーツアーしてやれば区間に部分木が入るので, 辺を降りるときに足して昇るときに引いてやればBITで各頂点からその子孫までの距離をO(log n)で得ることができる.<br />
辺の更新はBITで対応する位置に現在の値との差分を足してやれば良い.</p>

<p>上りと下りの区別がある場合<br />
パスの向きを考えるとu-&gt;w-&gt;vと進むことになることが分かる.<br />
もっと詳しく見ると<br />
u-&gt;wが根に向かって進む方向<br />
w-&gt;vが葉に向かって進む方向<br />
この2種類しかないので上りと下りをこれに対応させて2本のBIT, つまり根に向かう方向の距離を求めるのと葉に向かう方向の距離を求めるBITをそれぞれ別に用意すれば良い.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code JOI/2010/highway.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JOI 春合宿 2008 Typhoon]]></title>
    <link href="http://algoogle.hadrori.jp/joi/sc2008typhoon/"/>
    <updated>2014-09-04T17:27:48+09:00</updated>
    <id>http://algoogle.hadrori.jp/joi/sc2008typhoon</id>
    <content type="html"><![CDATA[<p><a href="http://joisc2008.contest.atcoder.jp/tasks/joisc2008_typhoon">Typhoon</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>n個の台風の被害にあった区間[s,t]の情報が与えられる.<br />
地点pに台風q号からr号までで被害にあった回数を答えるクエリm個を捌け</p>

<h4 id="section-1">解法</h4>

<hr />

<p>まず場所の範囲が大きいのでクエリで聞かれる場所だけで座標圧縮する.</p>

<p>n個の台風を平方分割する.<br />
分割された部分までの台風の情報をまとめて累積で持つ.<br />
分割部分からはみ出た部分はナイーブに計算する.<br />
分割部分はBITで持つことにする.</p>

<p>TLE厳し目なうえ, 分割数によってはMLEも厳しいのでsegreeを使う場合は気をつける</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code JOI/2008/Typhoon.cpp %}</p>
]]></content>
  </entry>
  
</feed>
