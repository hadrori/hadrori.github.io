<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: data-structure | Algoogle]]></title>
  <link href="http://algoogle.hadrori.jp/tags/data-structure/atom.xml" rel="self"/>
  <link href="http://algoogle.hadrori.jp/"/>
  <updated>2015-12-14T02:08:05+09:00</updated>
  <id>http://algoogle.hadrori.jp/</id>
  <author>
    <name><![CDATA[hadrori]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ 2674 Disordered Data Detection]]></title>
    <link href="http://algoogle.hadrori.jp/aoj/2674/"/>
    <updated>2015-10-18T15:55:39+09:00</updated>
    <id>http://algoogle.hadrori.jp/aoj/2674</id>
    <content type="html"><![CDATA[<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2674">Disordered Data Detection</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>長さDの整数列xがある．<br />
- 閉区間[l,r]にx[i]&lt;min(x[l],x[r])-eまたはmax(x[l],x[r])+e&lt;x[i]となるiの個数を求めよ<br />
というクエリがQ個くるのでそれに答えよ</p>

<h4 id="section-1">解法</h4>

<hr />

<p>データ構造で殴る．具体的にはwavelet行列．<br />
区間[l,r)に値が[a,b)に含まれるような値の個数は最大値をMとすると {% m %}O(\log{M}){% em %}で求められる．<br />
非負数は扱えないので適当に下駄を履かせる．</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code AOJ/2674.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[POI X Monkeys]]></title>
    <link href="http://algoogle.hadrori.jp/poi/poi10monkeys/"/>
    <updated>2014-11-04T16:50:20+09:00</updated>
    <id>http://algoogle.hadrori.jp/poi/poi10monkeys</id>
    <content type="html"><![CDATA[<p><a href="http://main.edu.pl/en/archive/oi/10/mal">Monkeys</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>n匹の猿がいて, 猿0は木にぶら下がっている.<br />
各猿は片手につき1匹まで他の猿のしっぽをつかむことができる.<br />
互いにつかみ合うことも可能.<br />
今, 時刻mまで各時刻のある1匹の猿のどちらかの手を離す情報が記録してある.<br />
当然手を離したら落ちてしまう猿がでてくる.<br />
各猿の落下する時刻を求めよ.<br />
落下しない場合は-1<br />
また, 猿ははじめ全員落下しないでぶら下がれている.</p>

<h4 id="section-1">解法</h4>

<hr />

<p>逆順に処理していけば良い.<br />
始めに時刻mからはじめる.<br />
このとき連結している猿同士を1つのグループとしてまとめて考える.<br />
これはUnion-Find木で管理すれば良い.<br />
また各グループにどの猿が属しているかの情報も持っておきたいので, 各グループの根の猿の番号をグループ番号として別個に猿の集合を持っておく.<br />
グループをマージするとき, どちらか一方のみが猿0と同じグループに属しているならもう片方のグループはその時刻に落ちたということがわかる.<br />
よってそのグループに属する猿の答えを記録し, マージする.<br />
Union-Findのマージはいいとして, 猿の集合のマージはデータ構造をマージする一般的なテクを使う(そうするとそのマージは全体でO(n)になる).</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code POI/X/monkeys.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JOI 春合宿 2012 Copy and Paste]]></title>
    <link href="http://algoogle.hadrori.jp/joi/sc2012copy-and-paste/"/>
    <updated>2014-10-13T18:11:49+09:00</updated>
    <id>http://algoogle.hadrori.jp/joi/sc2012copy-and-paste</id>
    <content type="html"><![CDATA[<p><a href="http://joisc2012.contest.atcoder.jp/tasks/joisc2012_copypaste">Copy and Paste</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>文字列を[l,r)をコピーして, 場所kに挿入するというクエリがN(&lt;=1000000)回くる.<br />
ただし毎回長さがM(&lt;=1000000)を超える場合はそれ以降は切り捨てる.<br />
最終的に作られる文字列を答えよ</p>

<h4 id="section-1">解法</h4>

<hr />

<p>永続赤黒木を使ってやる.<br />
<a href="http://www.ioi-jp.org/camp/2012/2012-sp-tasks/2012-sp-day4-copypaste-slides.pdf">解説スライド</a><br />
メモリが足りなくなったら木を再構築する.<br />
木を構築するときは文字列を半分にして右と左でできた木をマージする.<br />
ノードを再利用するのでノードのメモリ確保にnewするのではなく, 予め配列で用意しておいてそれを割り当てる.<br />
この配列から溢れる前に再構築する.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code JOI/2012/copy-and-paste.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces 374D Inna and Sequence]]></title>
    <link href="http://algoogle.hadrori.jp/codeforces/374d/"/>
    <updated>2014-07-13T14:56:21+09:00</updated>
    <id>http://algoogle.hadrori.jp/codeforces/374d</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/problemset/problem/374/D">Inna and Sequence</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>空の列wとm個の値が昇順に並んだ列aがある. 
入力が0か1だったらwの後ろにそれをつなげる.<br />
入力が-1だったら列wのa[i]番目の値をそれぞれ消し, その後詰める.<br />
操作後のwを出力しろ</p>

<h4 id="section-1">解法</h4>

<hr />

<p>まず入力をwに加えるものとwからいくつ消すかに分ける.<br />
wに加えるものを一度すべて並べたと考える.<br />
i番目を使うなら1, そうでないなら0とすればそこまでの和で壊されてないもののうち何番目かがわかる.<br />
これはBITで効率的に実装できる.<br />
壊れてないもののうちi番目の値を破壊するときは大きい方から順に和が初めてiになる場所を二分探索して探せば良い.<br />
その場所に0にすれば(-1加えれば)そこが破壊されたことになり, 以降の和も変化して順番が更新される.<br />
全ての破壊が終わったら1になっている場所の値を順に出力すればよい</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code Codeforces/374D.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces 375D Tree and Queries]]></title>
    <link href="http://algoogle.hadrori.jp/codeforces/375d/"/>
    <updated>2014-07-11T00:03:57+09:00</updated>
    <id>http://algoogle.hadrori.jp/codeforces/375d</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/problemset/problem/375/D">Tree and Queries</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>N(&lt;=100000)頂点の木の各頂点に色が塗られている. このとき以下のクエリに答えろ.<br />
頂点vの部分木にk個以上に塗られている色はいくつあるか</p>

<h4 id="section-1">解法</h4>

<hr />

<p>オイラーツアーして平方分割する.<br />
部分木の開始点を平方分割の各バケットの要素数Bごとに区切る.<br />
クエリをその開始点順にソートし, 同じバケットでは終了点順でソートしておくと開始点の各バケットでの移動は高々B回(オイラーツアーをしているので).<br />
また各バケットでのクエリの終了点の移動は高々N回になる.<br />
よって全体では{% m %}O(N\sqrt{M}){% em %}になる.</p>

<p>データ構造をマージする一般的なテクも使えるらしいのでコードを載せておいた.<br />
深い順にクエリを処理することで順にマージしていけるようにする.<br />
マージは大きいものを選んでそれに小さい方を愚直に突っ込んでいるだけ(直感的にはすごくTLEしそうな感じだ).<br />
マージ後の小さい方はclearしておかないとたぶんMLEする.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code Codeforces/375D.cpp %}</p>

<p>{% include_code Codeforces/375D1.cpp %}</p>
]]></content>
  </entry>
  
</feed>
