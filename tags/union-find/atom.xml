<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: union-find | Algoogle]]></title>
  <link href="http://algoogle.hadrori.jp/tags/union-find/atom.xml" rel="self"/>
  <link href="http://algoogle.hadrori.jp/"/>
  <updated>2015-12-14T02:08:05+09:00</updated>
  <id>http://algoogle.hadrori.jp/</id>
  <author>
    <name><![CDATA[hadrori]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ 2664 Shopping]]></title>
    <link href="http://algoogle.hadrori.jp/aoj/2664/"/>
    <updated>2015-10-18T16:17:58+09:00</updated>
    <id>http://algoogle.hadrori.jp/aoj/2664</id>
    <content type="html"><![CDATA[<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2664">Shopping</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>N個の材料がある．i番目の材料はx[i]円で買える．<br />
幾つかの材料は魔法で別の材料にすることができる．AからBにできるならBからAにもできる．<br />
必要な材料費の最小を求めよ．</p>

<h4 id="section-1">解法</h4>

<hr />

<p>Union Fnidで関係をマージしてグループ中の最小額を採用すればいい．</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code AOJ/2664.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[POI X Monkeys]]></title>
    <link href="http://algoogle.hadrori.jp/poi/poi10monkeys/"/>
    <updated>2014-11-04T16:50:20+09:00</updated>
    <id>http://algoogle.hadrori.jp/poi/poi10monkeys</id>
    <content type="html"><![CDATA[<p><a href="http://main.edu.pl/en/archive/oi/10/mal">Monkeys</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>n匹の猿がいて, 猿0は木にぶら下がっている.<br />
各猿は片手につき1匹まで他の猿のしっぽをつかむことができる.<br />
互いにつかみ合うことも可能.<br />
今, 時刻mまで各時刻のある1匹の猿のどちらかの手を離す情報が記録してある.<br />
当然手を離したら落ちてしまう猿がでてくる.<br />
各猿の落下する時刻を求めよ.<br />
落下しない場合は-1<br />
また, 猿ははじめ全員落下しないでぶら下がれている.</p>

<h4 id="section-1">解法</h4>

<hr />

<p>逆順に処理していけば良い.<br />
始めに時刻mからはじめる.<br />
このとき連結している猿同士を1つのグループとしてまとめて考える.<br />
これはUnion-Find木で管理すれば良い.<br />
また各グループにどの猿が属しているかの情報も持っておきたいので, 各グループの根の猿の番号をグループ番号として別個に猿の集合を持っておく.<br />
グループをマージするとき, どちらか一方のみが猿0と同じグループに属しているならもう片方のグループはその時刻に落ちたということがわかる.<br />
よってそのグループに属する猿の答えを記録し, マージする.<br />
Union-Findのマージはいいとして, 猿の集合のマージはデータ構造をマージする一般的なテクを使う(そうするとそのマージは全体でO(n)になる).</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code POI/X/monkeys.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JOI 春合宿 2010 Finals]]></title>
    <link href="http://algoogle.hadrori.jp/joi/sc2010finals/"/>
    <updated>2014-09-17T01:55:14+09:00</updated>
    <id>http://algoogle.hadrori.jp/joi/sc2010finals</id>
    <content type="html"><![CDATA[<p><a href="http://joisc2010.contest.atcoder.jp/tasks/joisc2010_finals">Finals</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>辺にコストのある無向グラフが与えられる.<br />
各頂点からK個の頂点を選んだとき, どの頂点もそのいずれかに到達できるように辺を選ぶ.<br />
使う辺のコストの和の最小を求めよ.</p>

<h4 id="section-1">解法</h4>

<hr />

<p>Kruskal法で最小全域木を求める要領でやる.<br />
今回は全域木ではなくてK個の木からなる全域森を考えれば良い.<br />
コストの小さい辺から選んでコストを足していき, 連結成分がK個になったら終了</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code JOI/2010/finals.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JOI 春合宿 2007 Fiber]]></title>
    <link href="http://algoogle.hadrori.jp/joi/sc2007fiber/"/>
    <updated>2014-08-28T02:28:41+09:00</updated>
    <id>http://algoogle.hadrori.jp/joi/sc2007fiber</id>
    <content type="html"><![CDATA[<p><a href="http://joisc2007.contest.atcoder.jp/tasks/joisc2007_fiber">Fiber</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>グラフが与えられるので, あと何本辺を追加すれば連結になるか</p>

<h4 id="section-1">解法</h4>

<hr />

<p>Union-Find木でグループを管理して, 各ペアを順に見てまだ違うグループだったら辺を追加する.<br />
この追加した辺の数を答えれば良い.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code JOI/2007/Fiber.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces 455C Civilization]]></title>
    <link href="http://algoogle.hadrori.jp/codeforces/455c/"/>
    <updated>2014-08-09T15:55:12+09:00</updated>
    <id>http://algoogle.hadrori.jp/codeforces/455c</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/455/problem/C">Civilization</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>森が与えられるので以下のクエリを処理しろ.</p>

<ul>
  <li>頂点xの属する木の直径を出力する</li>
  <li>頂点xとyが属する木を直径が最小になるようにマージする</li>
</ul>

<h4 id="section-1">解法</h4>

<hr />

<p>木の直径はある頂点vから一番遠い頂点uをもとめ(vはなんでもよい), uから一番遠い頂点までの距離.<br />
各頂点がどの木に属するかはunion-findで管理すれば良い.<br />
マージの仕方は, 両方の木の直径になるパスの真ん中を繋げば良い.<br />
マージされた木の直径はmax(diam[x], diam[y], (diam[x]+1)/2+(diam[y]+1)/2+1)になる.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code Codeforces/455C.cpp %}</p>
]]></content>
  </entry>
  
</feed>
