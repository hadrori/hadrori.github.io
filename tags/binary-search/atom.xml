<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: binary-search | Algoogle]]></title>
  <link href="http://algoogle.hadrori.jp/tags/binary-search/atom.xml" rel="self"/>
  <link href="http://algoogle.hadrori.jp/"/>
  <updated>2015-12-14T02:08:05+09:00</updated>
  <id>http://algoogle.hadrori.jp/</id>
  <author>
    <name><![CDATA[hadrori]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ 1178 A Broken Door]]></title>
    <link href="http://algoogle.hadrori.jp/aoj/1178/"/>
    <updated>2015-10-10T15:03:57+09:00</updated>
    <id>http://algoogle.hadrori.jp/aoj/1178</id>
    <content type="html"><![CDATA[<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1178">A Broken Door</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>左上の部屋から右下の部屋まで移動したい．部屋と部屋の間にはドアがあったりなかったり．<br />
ドアがあるところだけ移動できるが，今ドアがどこか1つだけ壊れている．ドアは通ろうとする時に初めて壊れているかどうかわかる．<br />
最悪の場合でも最低何回の移動で左上から右下の部屋に行けるか．</p>

<h4 id="section-1">解法</h4>

<hr />

<p>まず各ドア(方向も考慮する)について，そこが壊れていたときのそこから右下までの最短距離を求める．</p>

<p>最大の最小を求める．2分探索の典型．<br />
上限を決めてBFSする．ただしドアを通るとき，前に求めたコストとそこまでの距離の和が上限を超えない時だけ進める．</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code AOJ/1178.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[POI II The Coding of Permutations]]></title>
    <link href="http://algoogle.hadrori.jp/poi/poi2kod/"/>
    <updated>2014-11-02T13:03:25+09:00</updated>
    <id>http://algoogle.hadrori.jp/poi/poi2kod</id>
    <content type="html"><![CDATA[<p><a href="http://main.edu.pl/en/archive/oi/2/kod">The Coding of Permutations</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>1からnまでの整数を並び替えた数列をaとする.<br />
{% m %}b_{i}{% em %}をj&lt;iとなるjのうち{% m %}a_{j}{% em %}&gt;{% m %}a_{i}{% em %}となる数とする数列bが与えられる.<br />
数列aとして考えられるものを出力せよ. 存在しない場合はNIEと出せ.</p>

<h4 id="section-1">解法</h4>

<hr />

<p>数列を後ろから特定していく.<br />
値の候補の集合をSとし, i番目を見ているとき<br />
候補のうち{% m %}b_{i}{% em %}番目に大きい数を{% m %}a_{i}{% em %}とすればよい.<br />
その後候補から{% m %}a_{i}{% em %}を削除する.</p>

<p>あとは値の候補のうちk番目を見つけ, 削除できるようなデータ構造を考えれば良い.</p>

<p>今回はBITを使ってやることにした.<br />
簡単のため値は0からn-1で考える.<br />
値vを使ったら位置vに1を足す.<br />
すると位置jについてそれ以降に使われた値の個数というのがsum(j,n)でわかる.<br />
つまりj以降でまだ使われていない数はn-j-sum(j,n)個となる.<br />
あとは使われてない個数が{% m %}b_{i}+1{% em %}個になるような位置の最右端を二分探索すればよい.<br />
計算量は{% m %}O(n\log^{2}n){% em %}になる.</p>

<p>余談だが, 使ってないもののリストをvectorで持ち{% m %}b_{i}{% em %}番目を持ってきて削除とかはvectorのeraseが要素数の線形程度かかるので厳しい.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code POI/II/kod.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ACM-ICPC Tokyo Regional 2014 G Flipping Parentheses]]></title>
    <link href="http://algoogle.hadrori.jp/icpc/icpc2014tokyog/"/>
    <updated>2014-10-24T03:06:45+09:00</updated>
    <id>http://algoogle.hadrori.jp/icpc/icpc2014tokyog</id>
    <content type="html"><![CDATA[<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/cdescription.jsp?cid=ICPCOOC2014&amp;pid=G">Flipping Parentheses</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>バランスのとれた括弧の列が与えられる.<br />
q個のクエリについてそれぞれ指定された場所の括弧を反転させ, 再びバランスのとれた状態にするために反転させるべき一番左の括弧を求めよ</p>

<h4 id="section-1">解法</h4>

<hr />

<p>開き括弧を+1, 閉じ括弧を-1とみる.<br />
その累積和を取ったとき, バランスのとれた括弧の列なら常に非負かつ最後に0になる.</p>

<p>すでにクエリの括弧は反転させたとする.<br />
閉じ括弧を開き括弧に変える場合, 一番左の閉じ括弧に変えればよい(上の条件は常に満たされる).<br />
開き括弧を閉じ括弧に変える場合, 以降の最小値が2以上であるような一番左の場所を探す.<br />
これは2分探索をすればよい.</p>

<p>区間の最小値はSegment-Treeを使えば良い.<br />
累積和の更新は区間に2もしくは-2を加える事でできる.<br />
区間に足し込むタイプのSegment-Treeは区間に一気に足した値保持することで大抵うまくいく.<br />
一番左の閉じ括弧はsetとかで持てばよいでしょう.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code ICPC/2014/Tokyo/G.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JOI 春合宿 2011 IOI]]></title>
    <link href="http://algoogle.hadrori.jp/joi/sc2011ioi/"/>
    <updated>2014-10-01T00:38:51+09:00</updated>
    <id>http://algoogle.hadrori.jp/joi/sc2011ioi</id>
    <content type="html"><![CDATA[<p><a href="http://joisc2011.contest.atcoder.jp/tasks/joisc2011_ioi">IOI</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>K人のコンテスタントがいて, 総問題数NのうちM個が終わった時の得点が与えられる.<br />
全体の1/12人以上になるような点数のボーダーのうち, 最大の得点を金メダルのボーダーとする.<br />
このとき金メダルが確定している選手と, 金メダルの可能性がある選手を求めよ</p>

<h4 id="section-1">解法</h4>

<hr />

<p>金メダル確実な場合というのは自分が今後0点かつ他人がそれ以降全員満点をとっても自分より点数が大きい人がK/12人未満ということ.<br />
これは現在の得点でソートされた列に対して自分の得点-残り全て満点の点数でupper_boundをとればよい.<br />
ただし残りが0問の場合以外は自分もそこに含まれてしまうので除いておくこと.</p>

<p>金メダルの可能性があるというのは自分が今後満点かつ他人がそれ以降全員0点のとき自分より点数が大きい人がK/12人未満ということ.<br />
これは同じように自分の得点+残り全て満点の点数でupper_boundをとればよい.<br />
これには自分含まれることはない</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code JOI/2011/ioi.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JOI 春合宿 2011 Guess Them All]]></title>
    <link href="http://algoogle.hadrori.jp/joi/sc2011guess/"/>
    <updated>2014-09-23T01:13:04+09:00</updated>
    <id>http://algoogle.hadrori.jp/joi/sc2011guess</id>
    <content type="html"><![CDATA[<p><a href="http://joisc2011.contest.atcoder.jp/tasks/joisc2011_guess">Guess Them All</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>1からNまでの互いに異なる整数の順列がある.<br />
N個の数字(1以上N以下)を渡すと, 何個の数字の位置があっているかが返されるのでそれをL回以内で当てろ(Lは与えられない).</p>

<h4 id="section-1">解法</h4>

<hr />

<p>使える数字が1以上N以下で余計な数字を使えないので, はじめに1の位置を全部試して決定する.<br />
2以降はまだ値が決定していない位置で2分探索する.<br />
毎回全部の位置で2分探索するのはダメ(N=100のとき最大7回かかるので100個の区間で毎回やると始めの1の決定の100回と合わせて700回という制約を超える).</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code JOI/2011/guess.cpp %}</p>
]]></content>
  </entry>
  
</feed>
