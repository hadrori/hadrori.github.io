<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: dp | Algoogle]]></title>
  <link href="http://algoogle.hadrori.jp/tags/dp/atom.xml" rel="self"/>
  <link href="http://algoogle.hadrori.jp/"/>
  <updated>2015-12-14T02:08:05+09:00</updated>
  <id>http://algoogle.hadrori.jp/</id>
  <author>
    <name><![CDATA[hadrori]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ 2445 MinimumCostPath]]></title>
    <link href="http://algoogle.hadrori.jp/aoj/adventcalendar/2445/"/>
    <updated>2015-12-14T01:05:28+09:00</updated>
    <id>http://algoogle.hadrori.jp/aoj/adventcalendar/2445</id>
    <content type="html"><![CDATA[<p>AOJ-ICPC Advent Calendar 2015の14日目の記事です．</p>

<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2445">MinimumCostPath</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>n*nの2次元グリッドががある(n&lt;=1,000,000)．<br />
m(&lt;=50)個のマスが進入不可なとき，(1,1)から(n,n)までの最短ルートの個数をmod 1,000,000,009で求めよ．</p>

<h4 id="section-1">解法</h4>

<hr />

<p>まず右と上しか進めないときを考える．これは簡単で，以下の様なDPすればよい．<br />
dp[i] := i番目の障害物の場所に来る方法の総数<br />
更新はi番目の場所を(xi,yi)，(1,1)から(xi,yi)の矩形に含まれる障害物の番号の集合をSとすると</p>

<p>{% math %}</p>

<p>dp[i] = {}<em>{x_i+y_i}C</em>{x_i}-\sum_{j \in S} dp[j]*{}<em>{x_i-x_j+y_i-y_j}C</em>{x_i-x_j}</p>

<p>{% endmath %}</p>

<p>ではどのようなときに最短ルートが遠回りせざるを得ないか考える．<br />
これはどのルートを選択しても，必ず遠回りになる必要があり，そのために遠回りが確定するまで経路を障害物で覆う必要がある(終端からも同様)．<br />
つまり，障害物が50個程度しかないのでグリッドの縁を駆使しても左下と右上の50*50ぐらいの中ででしか遠回りは起こらない．<br />
このことを利用して，(1,1)からマンハッタン距離が50ぐらいのところを始点(もちろんその中で最短のものだけ)，(n,n)からマンハッタン距離が50ぐらいのところを終点としてその組合せで上のDPをして足し合わせればよい．</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code AOJ/2445.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ 2035 It Prefokery Pio]]></title>
    <link href="http://algoogle.hadrori.jp/aoj/2035/"/>
    <updated>2015-10-18T15:17:32+09:00</updated>
    <id>http://algoogle.hadrori.jp/aoj/2035</id>
    <content type="html"><![CDATA[<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2035">It Prefokery Pio</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>与えられる文字列の部分列のうち，最長の回文を求めよ．</p>

<h4 id="section-1">解法</h4>

<hr />

<p>長さについてDPして復元する．<br />
dp[l][r] := 区間[l,r]で最長の回文の長さ<br />
メモ化再帰が復元の経路を保存するのに楽で良い．</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code AOJ/2035.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ 1086 Live Schedule]]></title>
    <link href="http://algoogle.hadrori.jp/aoj/1086/"/>
    <updated>2015-10-10T15:42:33+09:00</updated>
    <id>http://algoogle.hadrori.jp/aoj/1086</id>
    <content type="html"><![CDATA[<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1086">Live Schedule</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>D日間のライブツアーをC地域でやる．<br />
地域iでj日目にライブをやるときに {% m %}E_{i,j}{% em %}だけの利益がある．利益が0の場所でライブはしない．<br />
同様に {% m %}F_{i,j}{% em %}だけ疲れる．<br />
全日程を通して疲労の累計はW以下．<br />
また，ある地域でライブが終わったあと，隣り合う番号の地域で続けてライブを行うことができる．ただし同じ日に同じ地域で2度以上ライブをすることはできない．<br />
さらに，2箇所以上でライブする日はX日以内．<br />
得られる利益の最大はいくらか．</p>

<h4 id="section-1">解法</h4>

<hr />

<p>DPする．<br />
dp[i][j][k] := i日目で疲労がj，2箇所以上でライブをしたのがk回のときの最大の利益<br />
ライブをする場所は間に0のない連続する区間．これは累積和を持っておけばO(1)で計算できる．</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code AOJ/1086.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ 0611 Silk Road]]></title>
    <link href="http://algoogle.hadrori.jp/aoj/0611/"/>
    <updated>2015-10-04T17:17:58+09:00</updated>
    <id>http://algoogle.hadrori.jp/aoj/0611</id>
    <content type="html"><![CDATA[<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0611">Silk Road</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>都市0から都市N(&lt;=1000)へ移動したい．<br />
都市iから都市i+1にj日目に移動するとき，{% m %}D_{i}\times C_{j}{% em %}だけ疲労度がたまる．<br />
M(&lt;=1000)日以内に移動するとき，都市0から都市Nまで移動した時の疲労度の最小を求めよ．</p>

<h4 id="section-1">解法</h4>

<hr />

<p>DPします．<br />
dp[i][j] := 都市iにj日目にいる時の疲労度の最小</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code AOJ/0611.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ 0570 Zig-Zag Numbers]]></title>
    <link href="http://algoogle.hadrori.jp/aoj/0570/"/>
    <updated>2015-10-04T16:54:49+09:00</updated>
    <id>http://algoogle.hadrori.jp/aoj/0570</id>
    <content type="html"><![CDATA[<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0570">Zig-Zag Numbers</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>ある数字の列について，その中の全ての数字がその隣り合う2つの数字より大きいか小さいとき，その列をジグザグ数という．<br />
A以上B以下のMの倍数のうち，ジグザグ数の個数はいくらか．</p>

<h4 id="section-1">解法</h4>

<hr />

<p>A, Bはむちゃくそでかいので当然順に調べることはできない．<br />
桁DPをする．左からそこまでmod Mをとった数と直前の数字を覚えていればできる．</p>

<p>dp[左からの位置][そこまでの数 mod M][直前の数][down, up, first][Aの境界上][Bの境界上][leading 0]</p>

<p>このまま配列をとるとMLEするのでposを0と1で使い回す．</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code AOJ/0570.cpp %}</p>
]]></content>
  </entry>
  
</feed>
