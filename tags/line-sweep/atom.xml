<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: line-sweep | Algoogle]]></title>
  <link href="http://algoogle.hadrori.jp/tags/line-sweep/atom.xml" rel="self"/>
  <link href="http://algoogle.hadrori.jp/"/>
  <updated>2015-12-14T02:08:05+09:00</updated>
  <id>http://algoogle.hadrori.jp/</id>
  <author>
    <name><![CDATA[hadrori]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ 1242 Area of Polygons]]></title>
    <link href="http://algoogle.hadrori.jp/aoj/1242/"/>
    <updated>2015-05-06T12:44:07+09:00</updated>
    <id>http://algoogle.hadrori.jp/aoj/1242</id>
    <content type="html"><![CDATA[<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1242">Area of Polygons</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>頂点が格子点上にある多角形が与えられる．<br />
多角形が通るマスと多角形に含まれるマスの数を答えよ．</p>

<h4 id="section-1">解法</h4>

<hr />

<p>y軸に平行な太さが1マス分の走査線で平面走査する．<br />
各線分から現在見てる区間を切り取って，左側のx座標でソートする．<br />
あとは足される区間と足さない区間が交互にくるので足してやればいい．<br />
y軸に平行な線分は無視．</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code AOJ/1242.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PA 2010 Sweets]]></title>
    <link href="http://algoogle.hadrori.jp/pa/pa2010sweets/"/>
    <updated>2014-11-01T22:15:50+09:00</updated>
    <id>http://algoogle.hadrori.jp/pa/pa2010sweets</id>
    <content type="html"><![CDATA[<p><a href="http://main.edu.pl/en/archive/pa/2010/cuk">Sweets</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>n(&lt;=24)個の箱にそれぞれ{% m %}a_{i}{% em %}個のお菓子がある.<br />
これを3人兄弟Anton, Dmytro, Borysで箱ごとに配りたい.<br />
できるだけ平等に分けるとき最小のAntonとBorysのもらう数の差を求めよ.<br />
ただしそれぞれのもらう数A, D, Bは{% m %} A \geq D \geq B{% em %}を満たさなければならない.</p>

<h4 id="section-1">解法</h4>

<hr />

<p>まずn個の箱を半分ずつ({% m %}n_{0},n_{1}{% em %})に分ける.<br />
これは半分ずつ全列挙することで全体で全列挙するのを抑えるため.<br />
それぞれの集合で3人がもらう数を{% m %}A_{i}, D_{i}, B_{i}{% em %}とする.<br />
{% m %}(A_{i}, D_{i}, B_{i}){% em %}のありうる組を全列挙しておく.<br />
列挙した組の集合をそれぞれ{% m %}K_{0}, K_{1}{% em %}とする.</p>

<p>ここで以下のような変換{% m %}K_{i} \rightarrow K’_{i}{% em %}をする.</p>

<p>{% math %}</p>

<p>K_{0} \rightarrow K’<em>{0}<br />
(A</em>{0}, D_{0}, B_{0}) \in K_{0} \rightarrow (A_{0}-D_{0}, D_{0}-B_{0}) \in K’<em>{0}<br />
<br />
K</em>{1} \rightarrow K’<em>{1}<br />
(A</em>{1}, D_{1}, B_{1}) \in K_{1} \rightarrow (D_{1}-A_{1}, B_{1}-D_{1}) \in K’_{1}\</p>

<p>{% endmath %}</p>

<p>これによって求める最小値は{% m %}K’<em>{0}, K’</em>{1}{% em %}の要素{% m %}(x_{0},y_{0}), (x_{1},y_{1}){% em %}について</p>

<p>{% math %}</p>

<p>(x_{0}+y_{0})-(x_{1}+y_{1})</p>

<p>{% endmath %}</p>

<p>の最小値となる.<br />
ただし{% m %}x_{0}\geq x_{1}, y_{0}\geq y_{1}{% em %}を満たす組のみ.<br />
なぜなら</p>

<p>{% math %}</p>

<p>A_{0}+A_{1} \leq D_{0}+D_{1}<br />
A_{0}-D_{0} \leq D_{1}-A_{1}<br />
<br />
D_{0}+D_{1} \leq B_{0}+B_{1}<br />
D_{0}-B_{0} \leq B_{1}-D_{1}\</p>

<p>{% endmath %}</p>

<p>を満たさなければならないから.</p>

<p>この条件から2次元上の最近点(マンハッタン距離)を求めれば良い.<br />
条件より{% m %}K’<em>{0}{% em %}の点を固定してと考えると, 最も近い{% m %}K’</em>{1}{% em %}の条件を満たす点というのは<br />
それより左下にあるもののうち, x+yが最大になる点とわかる.<br />
これは2つの集合の点を混ぜてyの昇順に見ていけば<br />
{% m %}K’<em>{0}{% em %}の点pのとき, それまでに出てきた{% m %}K’</em>{1}{% em %}の点のうちx座標についてp以下にあって, x+yが最大に点が一番近い.<br />
{% m %}K’_{1}{% em %}の点pのとき, 登場済みリストに入れる. ただしx座標についてそれ以降の点でx+yの値ががp以下のものは選ばれることが無い(もしくはそれを選ぶ必要がない)ので予め削除する.</p>

<p>2つ目の操作から登場済みリストはxについて単調増加であり, またx+yについて単調非減少になる.<br />
これの性質を利用することで1つ目の操作はx座標についてp以下のもののうち一番近いものを2分探索で選べばよく, 2つ目の操作はx座標についてp以上かつx+yについてp以下の点の区間を2分探索で求め削除することができる.</p>

<p>計算量は列挙に{% m %}O(3^{n/2}) = O(\sqrt{3}^{n}){% em %}, 各操作に{% m %}O(\log \sqrt{3}^{n}){% em %}となる.<br />
よって全体では{% m %}O(\sqrt(3)^{n}n) = O(1.74^{n}){% em %}となりなんとか間に合う.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code PA/2010/sweets.cpp %}</p>
]]></content>
  </entry>
  
</feed>
