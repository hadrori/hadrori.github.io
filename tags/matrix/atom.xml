<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: matrix | Algoogle]]></title>
  <link href="http://algoogle.hadrori.jp/tags/matrix/atom.xml" rel="self"/>
  <link href="http://algoogle.hadrori.jp/"/>
  <updated>2015-12-14T02:08:05+09:00</updated>
  <id>http://algoogle.hadrori.jp/</id>
  <author>
    <name><![CDATA[hadrori]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ 1314 Matrix Calculator]]></title>
    <link href="http://algoogle.hadrori.jp/aoj/1314/"/>
    <updated>2015-10-10T15:22:22+09:00</updated>
    <id>http://algoogle.hadrori.jp/aoj/1314</id>
    <content type="html"><![CDATA[<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1314">Matrix Calculator</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>BNFが与えられるので実装しろ．</p>

<h4 id="section-1">解法</h4>

<hr />

<p>実装するだけ．<br />
型を扱うのが面倒だったので全部行列として扱った．</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code AOJ/1314.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ 2397 Three-way Branch]]></title>
    <link href="http://algoogle.hadrori.jp/aoj/2397/"/>
    <updated>2015-10-04T17:06:17+09:00</updated>
    <id>http://algoogle.hadrori.jp/aoj/2397</id>
    <content type="html"><![CDATA[<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2397">Three-way Branch</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>幅W(&lt;=75)で高さH(&lt;=10^18)のグリッドがある．<br />
セルから移動できる先は左下か真下か右下だけ．<br />
途中に侵入不可能なマスがN(&lt;=30)個ある．<br />
グリッドの左上から右下まで移動する方法の数を求めよ．</p>

<h4 id="section-1">解法</h4>

<hr />

<p>侵入不可能なマスがない場合，普通に行列累乗してやればよい．<br />
なので侵入不可能なマスがある行まで行列累乗して，その行で侵入不可能なマスの場合の数を0にしてまた行列累乗するというのを繰り返す．</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code AOJ/2397.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Typical DP Contest M - 家]]></title>
    <link href="http://algoogle.hadrori.jp/tdpc/m/"/>
    <updated>2015-08-30T13:18:04+09:00</updated>
    <id>http://algoogle.hadrori.jp/tdpc/m</id>
    <content type="html"><![CDATA[<p><a href="http://tdpc.contest.atcoder.jp/tasks/tdpc_house">M - 家</a></p>

<h4 id="section">問題概要</h4>

<hr />

<h4 id="section-1">解法</h4>

<hr />

<p>まず1階だけの時の各部屋間の移動方法の数を求める．<br />
dp[i][j][k] := iから始めて回った部屋の集合jで今いる部屋がkのときのiからkまでの移動の方法数<br />
として2部屋間の移動の方法を数えるbitDPをする．</p>

<p>あとはこの2部屋間の移動方法数の行列をH乗してやって，部屋1から部屋1までの数を見れば良い．</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code TDPC/M.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LiveArchive 4332 Blocks for kids]]></title>
    <link href="http://algoogle.hadrori.jp/livearchive/4332/"/>
    <updated>2015-05-28T14:38:27+09:00</updated>
    <id>http://algoogle.hadrori.jp/livearchive/4332</id>
    <content type="html"><![CDATA[<p><a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=307&amp;page=show_problem&amp;problem=2333">Blocks for kids</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>4種類のピースがあって，高さ2で横がいくらかのパネルをそのピースを回転させずに使って埋める．<br />
横がn(&lt;=1,000,000,000)のパネルが渡された時，2人に分割して渡して敷き詰めさせるときの敷き詰め方の場合の数を求めよ．</p>

<h4 id="section-1">解法</h4>

<hr />

<p>長さxのパネルの埋め方{% m %}f(x){% em %}は</p>

<p>{% math %}</p>

<p>f(0) = 1<br />
f(1) = 2<br />
f(x) = 2(f(x-1)+f(x-2))</p>

<p>{% endmath %}</p>

<p>長さxのパネルを2人に分けて埋めるときの場合の数{% m %}g(x){% em %}は</p>

<p>{% math %}</p>

<p>g(0) = 1<br />
g(1) = 4<br />
g(x) = 2(g(x-1)+g(x-2))+f(x)</p>

<p>{% endmath %}</p>

<p>これで遷移行列を作って行列累乗すればよい</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code livearchive/4332.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ONTAK 2008 Leonardo's Numbers]]></title>
    <link href="http://algoogle.hadrori.jp/ontak/ontak2008leo/"/>
    <updated>2014-11-19T16:18:23+09:00</updated>
    <id>http://algoogle.hadrori.jp/ontak/ontak2008leo</id>
    <content type="html"><![CDATA[<p><a href="http://main.edu.pl/en/archive/ontak/2008/leo">Leonardo’s Numbers</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>{% math %}</p>

<p>L_{0} = L_{1} = 1<br />
L_{i+1} = L_{i}+L_{i-1}+1</p>

<p>{% endmath %}</p>

<p>数列Lについて,</p>

<p>{% math %}</p>

<p>\sum_{i=0}^{n} L_{i}^{k}</p>

<p>{% endmath %}</p>

<p>を求めよ</p>

<h4 id="section-1">解法</h4>

<hr />

<p>{% math %}</p>

<p>K_{i} = L_{i} + 1</p>

<p>{% endmath %}</p>

<p>と数列Kを定義すると</p>

<p>{% math %}</p>

<p>K_{0} = K_{1} = 2<br />
K_{i+1} = K_{i}+K_{i-1}</p>

<p>{% endmath %}</p>

<p>と数列Kを表現できる(Kの各値はそれぞれフィボナッチ数列の値を2倍したものになる).<br />
求めたい値はKを用いて</p>

<p>{% math %}</p>

<p>\sum_{i=0}^{n}L_{i}^{k} = \sum_{i=0}^{n}(K_{i}-1)^{k} <br />
 = \sum_{i=0}^{n}\sum_{j=0}^{k} {}<em>{k}C</em>{j} (-1)^{k-j} K_{i}^{j} <br />
 = \sum_{j=0}^{k} {}<em>{k}C</em>{j} (-1)^{k-j} \sum_{i=0}^{n} K_{i}^{j} \</p>

<p>{% endmath %}</p>

<p>組合せはパスカルの三角形を予め作っておくことでO(1)で求められる.<br />
つまり{% m %}\sum_{i=0}^{n} K_{i}^{j}{% em %}を高速に求められればそれをk回繰り返す(高々13回)ことで何とかなりそう.<br />
{% m %}K_{i+1}{% em %}は{% m %}K_{i}, K_{i-1}{% em %}に, それまでの和{% m %}S_{i,k}{% em %}は{% m %}S_{i-1,k}, K_{i}{% em %}に依存することに注意すると<br />
フィボナッチ数を求める時みたいに行列累乗で求められることがわかる.<br />
なぜなら</p>

<p>{% math %}</p>

<p>K_{i+1}^{j}K_{i}^{k-j} = (K_{i}+K_{i-1})^{j}K_{i}^{k-j}<br />
 = \sum_{l=0}^{j} {}<em>{j}C</em>{l} K_{i}^{k-j+l} K_{i-1}^{j-l}</p>

<p>{% endmath %}</p>

<p>となるから.</p>

<p>{% math %}</p>

<p>\left(
\begin{array}{cccccc}
        S_{i,k} <br />
        K_{i+1}^{k} <br />
        \vdots <br />
        K_{i+1}^{j}K_{i}^{k-j} <br />
        \vdots <br />
        K_{i}^{k} <br />
\end{array}
\right) = \left(
\begin{array}{cccccc}
        1 &amp; 1 &amp; 0 &amp; \cdots &amp; \cdots &amp; \cdots &amp; 0 <br />
        0 &amp; {}<em>{k}C</em>{0} &amp; {}<em>{k}C</em>{1} &amp; \cdots &amp; \cdots &amp; \cdots &amp; {}<em>{k}C</em>{k} <br />
        \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots <br />
        0 &amp; {}<em>{k-j}C</em>{0} &amp; {}<em>{k-j}C</em>{0} &amp; \cdots &amp; {}<em>{k-j}C</em>{k-j} &amp; \cdots &amp; 0 <br />
        \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots <br />
        0 &amp; {}<em>{0}C</em>{0} &amp; 0 &amp; \cdots &amp; \cdots &amp; \cdots &amp; 0
\end{array}
\right) \left(
\begin{array}{cccccc}
        S_{i-1,k} <br />
        K_{i}^{k} <br />
        \vdots <br />
        K_{i}^{j}K_{i-1}^{k-j} <br />
        \vdots <br />
        K_{i-1}^{k} <br />
\end{array}
\right)
{% endmath %}</p>

<p>つまり</p>

<p>{% math %}</p>

<p>\left(
\begin{array}{cccccc}
        S_{n,k} <br />
        K_{n+1}^{k} <br />
        \vdots <br />
        K_{n+1}^{j}K_{n}^{k-j} <br />
        \vdots <br />
        K_{n}^{k} <br />
\end{array}
\right) = \left(
\begin{array}{cccccc}
        1 &amp; 1 &amp; 0 &amp; \cdots &amp; \cdots &amp; \cdots &amp; 0 <br />
        0 &amp; {}<em>{k}C</em>{0} &amp; {}<em>{k}C</em>{1} &amp; \cdots &amp; \cdots &amp; \cdots &amp; {}<em>{k}C</em>{k} <br />
        \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots <br />
        0 &amp; {}<em>{k-j}C</em>{0} &amp; {}<em>{k-j}C</em>{0} &amp; \cdots &amp; {}<em>{k-j}C</em>{k-j} &amp; \cdots &amp; 0 <br />
        \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots <br />
        0 &amp; {}<em>{0}C</em>{0} &amp; 0 &amp; \cdots &amp; \cdots &amp; \cdots &amp; 0
\end{array}
\right)^{n} \left(
\begin{array}{cccccc}
        2^{k} <br />
        2^{k} <br />
        \vdots <br />
        2^{k} <br />
        \vdots <br />
        2^{k} <br />
\end{array}
\right)
{% endmath %}</p>

<p>この計算は{% m %}O(k^{3}\log n){% em %}ででき,<br />
全体では{% m %}O(k^{4}\log n){% em %}となる.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code ONTAK/2008/leo.cpp %}</p>
]]></content>
  </entry>
  
</feed>
