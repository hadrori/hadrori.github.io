<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: math | Algoogle]]></title>
  <link href="http://algoogle.hadrori.jp/tags/math/atom.xml" rel="self"/>
  <link href="http://algoogle.hadrori.jp/"/>
  <updated>2015-07-30T15:13:28+09:00</updated>
  <id>http://algoogle.hadrori.jp/</id>
  <author>
    <name><![CDATA[hadrori]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ 1060 No Story]]></title>
    <link href="http://algoogle.hadrori.jp/aoj/1060/"/>
    <updated>2015-03-28T23:41:08+09:00</updated>
    <id>http://algoogle.hadrori.jp/aoj/1060</id>
    <content type="html"><![CDATA[<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1060">No Story</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>LCMがL(&lt;=1,000,000,000,000)になる2整数a,b(a&lt;=b)の組の数</p>

<h4 id="section-1">解法</h4>

<hr />

<p>{% math %}</p>

<p>L = p_{0}^{e_{0}}p_{1}^{e_{1}}…p_{k}^{e_{k}}</p>

<p>{% endmath %}</p>

<p>pは素数とする.<br />
このときある2数のLCMがLになるには, 各pについて2数のどちらかは {% m %} p^{e} {% em %}を含む.<br />
もう片方のpは0からe乗のいずれかになる.<br />
その組合せを考えれば良い.</p>

<p>{% math %}</p>

<p>(1+\prod_{i=0}^{k} (2e_{i}+1))/2</p>

<p>{% endmath %}</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code AOJ/1060.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ 2214 Warp Hall]]></title>
    <link href="http://algoogle.hadrori.jp/aoj/2214/"/>
    <updated>2015-01-16T00:00:38+09:00</updated>
    <id>http://algoogle.hadrori.jp/aoj/2214</id>
    <content type="html"><![CDATA[<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2214">Warp Hall</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>格子上を(1,1)から(n,m)に移動するとき, その移動方法の数を求める.<br />
ただし移動はy軸方向に+1するか, x軸方向に+1するかしかできない.<br />
また途中に入口と出口が固定されたワープホールがあり, 入口の点からは出口の点にしか移動できない.</p>

<h4 id="section-1">解法</h4>

<hr />

<p>始点からある点p(x,y)に到達する場合の数を考える.<br />
まずワープホールがない場合pに到達するを数える(これは余裕).<br />
pより左下にワープホールの入口wsが存在するとき, 始点-&gt;ws-&gt;pと移動するような場合の数が減る.<br />
pより左下にワープホールの出口wtが存在するとき, 始点-&gt;ws-&gt;wt-&gt;pと移動するような場合の数が増える.<br />
つまり始点からpに到達する場合の数は, 始点からwsに到達する場合の数がわかればよい.<br />
よってワープホールをx座標, y座標の順(左下に来るものが先に来るよう)にソートしてDPをすればよい.</p>

<p>dp[i] := i番目のワープホールの入口に到達する場合の数</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code AOJ/2214.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ONTAK 2008 Leonardo's Numbers]]></title>
    <link href="http://algoogle.hadrori.jp/ontak/ontak2008leo/"/>
    <updated>2014-11-19T16:18:23+09:00</updated>
    <id>http://algoogle.hadrori.jp/ontak/ontak2008leo</id>
    <content type="html"><![CDATA[<p><a href="http://main.edu.pl/en/archive/ontak/2008/leo">Leonardo’s Numbers</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>{% math %}</p>

<p>L_{0} = L_{1} = 1<br />
L_{i+1} = L_{i}+L_{i-1}+1</p>

<p>{% endmath %}</p>

<p>数列Lについて,</p>

<p>{% math %}</p>

<p>\sum_{i=0}^{n} L_{i}^{k}</p>

<p>{% endmath %}</p>

<p>を求めよ</p>

<h4 id="section-1">解法</h4>

<hr />

<p>{% math %}</p>

<p>K_{i} = L_{i} + 1</p>

<p>{% endmath %}</p>

<p>と数列Kを定義すると</p>

<p>{% math %}</p>

<p>K_{0} = K_{1} = 2<br />
K_{i+1} = K_{i}+K_{i-1}</p>

<p>{% endmath %}</p>

<p>と数列Kを表現できる(Kの各値はそれぞれフィボナッチ数列の値を2倍したものになる).<br />
求めたい値はKを用いて</p>

<p>{% math %}</p>

<p>\sum_{i=0}^{n}L_{i}^{k} = \sum_{i=0}^{n}(K_{i}-1)^{k} <br />
 = \sum_{i=0}^{n}\sum_{j=0}^{k} {}<em>{k}C</em>{j} (-1)^{k-j} K_{i}^{j} <br />
 = \sum_{j=0}^{k} {}<em>{k}C</em>{j} (-1)^{k-j} \sum_{i=0}^{n} K_{i}^{j} \</p>

<p>{% endmath %}</p>

<p>組合せはパスカルの三角形を予め作っておくことでO(1)で求められる.<br />
つまり{% m %}\sum_{i=0}^{n} K_{i}^{j}{% em %}を高速に求められればそれをk回繰り返す(高々13回)ことで何とかなりそう.<br />
{% m %}K_{i+1}{% em %}は{% m %}K_{i}, K_{i-1}{% em %}に, それまでの和{% m %}S_{i,k}{% em %}は{% m %}S_{i-1,k}, K_{i}{% em %}に依存することに注意すると<br />
フィボナッチ数を求める時みたいに行列累乗で求められることがわかる.<br />
なぜなら</p>

<p>{% math %}</p>

<p>K_{i+1}^{j}K_{i}^{k-j} = (K_{i}+K_{i-1})^{j}K_{i}^{k-j}<br />
 = \sum_{l=0}^{j} {}<em>{j}C</em>{l} K_{i}^{k-j+l} K_{i-1}^{j-l}</p>

<p>{% endmath %}</p>

<p>となるから.</p>

<p>{% math %}</p>

<p>\left(
\begin{array}{cccccc}
        S_{i,k} <br />
        K_{i+1}^{k} <br />
        \vdots <br />
        K_{i+1}^{j}K_{i}^{k-j} <br />
        \vdots <br />
        K_{i}^{k} <br />
\end{array}
\right) = \left(
\begin{array}{cccccc}
        1 &amp; 1 &amp; 0 &amp; \cdots &amp; \cdots &amp; \cdots &amp; 0 <br />
        0 &amp; {}<em>{k}C</em>{0} &amp; {}<em>{k}C</em>{1} &amp; \cdots &amp; \cdots &amp; \cdots &amp; {}<em>{k}C</em>{k} <br />
        \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots <br />
        0 &amp; {}<em>{k-j}C</em>{0} &amp; {}<em>{k-j}C</em>{0} &amp; \cdots &amp; {}<em>{k-j}C</em>{k-j} &amp; \cdots &amp; 0 <br />
        \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots <br />
        0 &amp; {}<em>{0}C</em>{0} &amp; 0 &amp; \cdots &amp; \cdots &amp; \cdots &amp; 0
\end{array}
\right) \left(
\begin{array}{cccccc}
        S_{i-1,k} <br />
        K_{i}^{k} <br />
        \vdots <br />
        K_{i}^{j}K_{i-1}^{k-j} <br />
        \vdots <br />
        K_{i-1}^{k} <br />
\end{array}
\right)
{% endmath %}</p>

<p>つまり</p>

<p>{% math %}</p>

<p>\left(
\begin{array}{cccccc}
        S_{n,k} <br />
        K_{n+1}^{k} <br />
        \vdots <br />
        K_{n+1}^{j}K_{n}^{k-j} <br />
        \vdots <br />
        K_{n}^{k} <br />
\end{array}
\right) = \left(
\begin{array}{cccccc}
        1 &amp; 1 &amp; 0 &amp; \cdots &amp; \cdots &amp; \cdots &amp; 0 <br />
        0 &amp; {}<em>{k}C</em>{0} &amp; {}<em>{k}C</em>{1} &amp; \cdots &amp; \cdots &amp; \cdots &amp; {}<em>{k}C</em>{k} <br />
        \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots <br />
        0 &amp; {}<em>{k-j}C</em>{0} &amp; {}<em>{k-j}C</em>{0} &amp; \cdots &amp; {}<em>{k-j}C</em>{k-j} &amp; \cdots &amp; 0 <br />
        \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots <br />
        0 &amp; {}<em>{0}C</em>{0} &amp; 0 &amp; \cdots &amp; \cdots &amp; \cdots &amp; 0
\end{array}
\right)^{n} \left(
\begin{array}{cccccc}
        2^{k} <br />
        2^{k} <br />
        \vdots <br />
        2^{k} <br />
        \vdots <br />
        2^{k} <br />
\end{array}
\right)
{% endmath %}</p>

<p>この計算は{% m %}O(k^{3}\log n){% em %}ででき,<br />
全体では{% m %}O(k^{4}\log n){% em %}となる.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code ONTAK/2008/leo.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PA 2011 Plotter]]></title>
    <link href="http://algoogle.hadrori.jp/pa/pa2011plotter/"/>
    <updated>2014-11-06T02:25:21+09:00</updated>
    <id>http://algoogle.hadrori.jp/pa/pa2011plotter</id>
    <content type="html"><![CDATA[<p><a href="http://main.edu.pl/en/archive/pa/2011/plo">Plotter</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>{% math %}</p>

<p>L_{1} = L<br />
\rightarrow _L_ \rightarrow LLR = L_{2}<br />
\rightarrow _L_L_R_ \rightarrow LLRLLRR = L_{3}\</p>

<p>{% endmath %}</p>

<p>というように, 次の列は前の列の文字の間にLとRを交互に挿入したもののn個目の列を考える.</p>

<p>原点から初めて(1,1)に線分を伸ばしたものを考える.<br />
そこからさっきの列を左からみていき, Lなら左に{% m %}sqrt{2}{% em %}進め, Rなら右に{% m %}sqrt{2}{% em %}進める.<br />
このときm個の座標について, その点を通る回数と通る時刻を列挙せよ</p>

<h4 id="section-1">解法</h4>

<hr />

<p>列は以下の様な定義に書き換えることができる.</p>

<p>{% math %}</p>

<p>L_{1} = L<br />
L_{i} = L_{i-1}Lr(L_{i})\</p>

<p>{% endmath %}</p>

<p>r()は文字列の順序を反転させ, さらにLとRを入れ替えたもの.<br />
また, {% m %}L_{i}{% em %}が終わった時点での位置は</p>

<p>{% math %}</p>

<p>x_{i} = x_{i-1}-y_{i-1}<br />
y_{i} = x_{i-1}+y_{i-1}\</p>

<p>{% endmath %}</p>

<p>nは2000ぐらいだが, クエリで来る座標が{% m %}10^{9}{% em %}程度なので終端点が大幅にはみ出たら適当に打ち切ればいい.</p>

<p>列の新しい定義から, 折れ線の最初と最後の2つに分けて再帰的にみれば線分上にある場合の端点からの距離がわかる.</p>

<p>{% math %}</p>

<p>d(x,y,n) = d(x,y,n-1) \cup {2^{n}-k: k\in d(y_{n}-y,x-x_{n},n-1)}</p>

<p>{% endmath %}</p>

<p>しかしこれでは{% m %}O(2^{n}){% em %}で死ぬので枝刈りを入れる.<br />
得られる折れ線を囲む四角形を考える. その外なら打ち切る.<br />
原点からの4辺までの距離(原点は四角形の内部であることに注意する)をr, t, l, bとする.</p>

<p>{% math %}</p>

<p>r_{1} = t_{1} = 1<br />
l_{1} = b_{1} = 0\</p>

<p>r_{i} = max(r_{i-1}, t_{i-1}+x_{i})<br />
t_{i} = max(t_{i-1}, l_{i-1}+y_{i})<br />
l_{i} = max(l_{i-1}, b_{i-1}-x_{i})<br />
b_{i} = max(b_{i-1}, r_{i-1}-y_{i})\</p>

<p>{% endmath %}</p>

<p>この枝刈りは根本的で, {% m %}O(n){% em %}まで削ることができる.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code PA/2011/Plotter.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PA 2010 Sweets]]></title>
    <link href="http://algoogle.hadrori.jp/pa/pa2010sweets/"/>
    <updated>2014-11-01T22:15:50+09:00</updated>
    <id>http://algoogle.hadrori.jp/pa/pa2010sweets</id>
    <content type="html"><![CDATA[<p><a href="http://main.edu.pl/en/archive/pa/2010/cuk">Sweets</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>n(&lt;=24)個の箱にそれぞれ{% m %}a_{i}{% em %}個のお菓子がある.<br />
これを3人兄弟Anton, Dmytro, Borysで箱ごとに配りたい.<br />
できるだけ平等に分けるとき最小のAntonとBorysのもらう数の差を求めよ.<br />
ただしそれぞれのもらう数A, D, Bは{% m %} A \geq D \geq B{% em %}を満たさなければならない.</p>

<h4 id="section-1">解法</h4>

<hr />

<p>まずn個の箱を半分ずつ({% m %}n_{0},n_{1}{% em %})に分ける.<br />
これは半分ずつ全列挙することで全体で全列挙するのを抑えるため.<br />
それぞれの集合で3人がもらう数を{% m %}A_{i}, D_{i}, B_{i}{% em %}とする.<br />
{% m %}(A_{i}, D_{i}, B_{i}){% em %}のありうる組を全列挙しておく.<br />
列挙した組の集合をそれぞれ{% m %}K_{0}, K_{1}{% em %}とする.</p>

<p>ここで以下のような変換{% m %}K_{i} \rightarrow K’_{i}{% em %}をする.</p>

<p>{% math %}</p>

<p>K_{0} \rightarrow K’<em>{0}<br />
(A</em>{0}, D_{0}, B_{0}) \in K_{0} \rightarrow (A_{0}-D_{0}, D_{0}-B_{0}) \in K’<em>{0}<br />
<br />
K</em>{1} \rightarrow K’<em>{1}<br />
(A</em>{1}, D_{1}, B_{1}) \in K_{1} \rightarrow (D_{1}-A_{1}, B_{1}-D_{1}) \in K’_{1}\</p>

<p>{% endmath %}</p>

<p>これによって求める最小値は{% m %}K’<em>{0}, K’</em>{1}{% em %}の要素{% m %}(x_{0},y_{0}), (x_{1},y_{1}){% em %}について</p>

<p>{% math %}</p>

<p>(x_{0}+y_{0})-(x_{1}+y_{1})</p>

<p>{% endmath %}</p>

<p>の最小値となる.<br />
ただし{% m %}x_{0}\geq x_{1}, y_{0}\geq y_{1}{% em %}を満たす組のみ.<br />
なぜなら</p>

<p>{% math %}</p>

<p>A_{0}+A_{1} \leq D_{0}+D_{1}<br />
A_{0}-D_{0} \leq D_{1}-A_{1}<br />
<br />
D_{0}+D_{1} \leq B_{0}+B_{1}<br />
D_{0}-B_{0} \leq B_{1}-D_{1}\</p>

<p>{% endmath %}</p>

<p>を満たさなければならないから.</p>

<p>この条件から2次元上の最近点(マンハッタン距離)を求めれば良い.<br />
条件より{% m %}K’<em>{0}{% em %}の点を固定してと考えると, 最も近い{% m %}K’</em>{1}{% em %}の条件を満たす点というのは<br />
それより左下にあるもののうち, x+yが最大になる点とわかる.<br />
これは2つの集合の点を混ぜてyの昇順に見ていけば<br />
{% m %}K’<em>{0}{% em %}の点pのとき, それまでに出てきた{% m %}K’</em>{1}{% em %}の点のうちx座標についてp以下にあって, x+yが最大に点が一番近い.<br />
{% m %}K’_{1}{% em %}の点pのとき, 登場済みリストに入れる. ただしx座標についてそれ以降の点でx+yの値ががp以下のものは選ばれることが無い(もしくはそれを選ぶ必要がない)ので予め削除する.</p>

<p>2つ目の操作から登場済みリストはxについて単調増加であり, またx+yについて単調非減少になる.<br />
これの性質を利用することで1つ目の操作はx座標についてp以下のもののうち一番近いものを2分探索で選べばよく, 2つ目の操作はx座標についてp以上かつx+yについてp以下の点の区間を2分探索で求め削除することができる.</p>

<p>計算量は列挙に{% m %}O(3^{n/2}) = O(\sqrt{3}^{n}){% em %}, 各操作に{% m %}O(\log \sqrt{3}^{n}){% em %}となる.<br />
よって全体では{% m %}O(\sqrt(3)^{n}n) = O(1.74^{n}){% em %}となりなんとか間に合う.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code PA/2010/sweets.cpp %}</p>
]]></content>
  </entry>
  
</feed>
