<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: lowest-common-ancestor | Algoogle]]></title>
  <link href="http://algoogle.hadrori.jp/tags/lowest-common-ancestor/atom.xml" rel="self"/>
  <link href="http://algoogle.hadrori.jp/"/>
  <updated>2015-07-30T15:13:28+09:00</updated>
  <id>http://algoogle.hadrori.jp/</id>
  <author>
    <name><![CDATA[hadrori]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JOI 春合宿 2010 Highway]]></title>
    <link href="http://algoogle.hadrori.jp/joi/sc2010highway/"/>
    <updated>2014-09-19T22:36:03+09:00</updated>
    <id>http://algoogle.hadrori.jp/joi/sc2010highway</id>
    <content type="html"><![CDATA[<p><a href="http://joisc2010.contest.atcoder.jp/tasks/joisc2010_highway">Highway</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>木が与えられる.<br />
ノードの番号が小さい方から大きい方へいく時を上りといい, 逆の時を下りという.<br />
以下のクエリを処理しろ.</p>

<ul>
  <li>ある辺の上りと下りにかかる時間の変更</li>
  <li>ある2頂点x, yのxからyにいくときにかかる時間の総和の出力</li>
</ul>

<h4 id="section-1">解法</h4>

<hr />

<p>根付き木として考える.<br />
頂点uから頂点vまでの距離を求めたい.<br />
上りと下りの区別がないとして考える.<br />
上りと下りの区別がないとき, 2頂点間の距離はその最小共通祖先wまでの距離の和と考えるとよい.<br />
こうするとオイラーツアーしてやれば区間に部分木が入るので, 辺を降りるときに足して昇るときに引いてやればBITで各頂点からその子孫までの距離をO(log n)で得ることができる.<br />
辺の更新はBITで対応する位置に現在の値との差分を足してやれば良い.</p>

<p>上りと下りの区別がある場合<br />
パスの向きを考えるとu-&gt;w-&gt;vと進むことになることが分かる.<br />
もっと詳しく見ると<br />
u-&gt;wが根に向かって進む方向<br />
w-&gt;vが葉に向かって進む方向<br />
この2種類しかないので上りと下りをこれに対応させて2本のBIT, つまり根に向かう方向の距離を求めるのと葉に向かう方向の距離を求めるBITをそれぞれ別に用意すれば良い.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code JOI/2010/highway.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces 379F New Year Tree]]></title>
    <link href="http://algoogle.hadrori.jp/codeforces/379f/"/>
    <updated>2014-07-09T02:04:27+09:00</updated>
    <id>http://algoogle.hadrori.jp/codeforces/379f</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/problemset/problem/379/F">New Year Tree</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>はじめに根1とその3つの子2~4がある.<br />
q(&lt;=5e5)回の以下のクエリを捌け.</p>

<ul>
  <li>頂点vに2つの頂点を加え, 木の直径を答える</li>
</ul>

<h4 id="section-1">解法</h4>

<hr />

<p>木の直径は一番離れた2点の距離.<br />
初期では頂点2, 3の距離が当てはまる.<br />
頂点を追加するたびにその頂点と, 現在の直径で使われている2点の距離をみる.<br />
もし距離が大きくなるなら頂点を交換する.<br />
距離はLCAを求めればよいのでO(log n)で計算可能.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code Codeforces/379F.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces 418D Big Problems for Organizers]]></title>
    <link href="http://algoogle.hadrori.jp/codeforces/418d/"/>
    <updated>2014-06-28T00:32:28+09:00</updated>
    <id>http://algoogle.hadrori.jp/codeforces/418d</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/problemset/problem/418/D">Big Problems for Organizers</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>頂点数n(&lt;=100000)の木が与えられる. この時m回以下のクエリが与えられる.<br />
頂点u, vから最も遠い点との距離はいくらか. ただし距離はu, vからのそれぞれの距離のうち小さい方を使う.</p>

<h4 id="section-1">解法</h4>

<hr />

<p>便宜上適当な頂点を根としておく.<br />
2頂点の中間部分で木を分解すれば, その木の根をそれぞれu, vとすることで木の高さが最長距離に当たる.</p>

<p>クエリのu, vは深さの降順になっているとする.<br />
w = LCA(u,v)とすると, 分割点cはdepth[u] = depth[v]ならw, そうでないならuとwの間にある.</p>

<p>そうするとuを含む方の木は以下の場合分けで高さが求まる.</p>

<ul>
  <li>元の木でuの子孫に最も遠い点がある</li>
  <li>uとcの間にuから最も遠い点がある</li>
</ul>

<p>部分木の高さは各点の深さと一緒に計算すればよい(O(n)).<br />
ここでuとcの間というのは, uの祖先だけでなく, 祖先の子孫も含む(ただしu以下は含まない).<br />
これはdoublingで2の冪個先の祖先までの区間について求めておけばO(log n)で求まる(構築はO(n log n)).<br />
これでuを含む方の木については調べられた.</p>

<p>v(とw)を含む木の方は, 以下の場合分けで求まる</p>

<ul>
  <li>vの子孫に最も遠い点がある</li>
  <li>vとwの間にvまでの最も遠い点がある</li>
  <li>wと根の間にvまでの最も遠い点がある</li>
  <li>vとcの間にvまでの最も遠い点がある</li>
  <li>その他のwの子孫(子供が根になる部分木にv, cを含まない)に最も遠い点がある</li>
</ul>

<p>始めの3つはuの時と同じdoublingで求めてあるやつを使えば良い.<br />
4つ目は今までのと似ているが, 基準の点が祖先の方なので別に用意する(似たようなdoublingをするだけ).<br />
最後は各頂点に対してその頂点を根とする部分木の高さを求めるとき, その子を根とする部分木の高さが最も大きい3つを保存すれば良い.<br />
そのとき子供の番号も保存しておけば, その頂点がvまたはcの祖先にいるかで使うかどうかを決めることができる.</p>

<p>以上をバグらないように実装する.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code Codeforces/418D.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PKU 1986 Distance Queries]]></title>
    <link href="http://algoogle.hadrori.jp/pku/1986/"/>
    <updated>2014-05-04T15:39:09+09:00</updated>
    <id>http://algoogle.hadrori.jp/pku/1986</id>
    <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=1986">Distance Queries</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>全域木になるようなグラフが与えられ, 各枝には重みが付いている.<br />
頂点数はN(&lt;=40,000)<br />
そのとき, K(&lt;=10,000)回クエリが与えられる. 各クエリでは2点が与えられるのでその2点の木の上での距離を答えよ.<br /></p>

<h4 id="section-1">解法</h4>

<hr />

<p>愚直にやると, 各クエリでO(N)かかるので全体でO(NK)で話にならない.<br />
木の上での2点の距離は2点のLCAを仲介にして距離を求めることができる.<br />
DFSで頂点を全てみるときの順番(戻るときも含める)に各点のDFSの深さを保存しておく.<br />
そうすると2点の間の深さの最小を取ってくればそれがLCAになる.<br />
明らかにRMQなのでSegment Treeで実装する.<br />
<br />
また, 各点からその各祖先までの距離もそのDFSの順に求める. 頂点に入るときに辺の重みを足し, 戻るときに引けばBITで区間の距離の総和が出せる(ただし各祖先までの距離しか出せない).<br />
よって2点の距離はそのLCAを介することで求められる.<br />
<br />
DFSの順番について, 例えば以下の図のように探索するとき頂点の列は<br />
1 2 5 2 6 2 1 3 1 4 1<br />
となり, それに対応する深さの列は<br />
0 1 2 1 2 0 1 0 1 0<br />
となり, 各頂点について頂点に入るときの列の場所を覚えておけばその区間を見るだけでよいことがわかる<br /></p>

<p><img src="/images/pku1986-01.png" alt="" /></p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code PKU/1986.cpp %}</p>

]]></content>
  </entry>
  
</feed>
