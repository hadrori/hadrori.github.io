<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: lowest-common-ancestor | Algoogle]]></title>
  <link href="http://algoogle.hadrori.jp/tags/lowest-common-ancestor/atom.xml" rel="self"/>
  <link href="http://algoogle.hadrori.jp/"/>
  <updated>2015-12-14T02:08:05+09:00</updated>
  <id>http://algoogle.hadrori.jp/</id>
  <author>
    <name><![CDATA[hadrori]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ 2270 The L-th Number]]></title>
    <link href="http://algoogle.hadrori.jp/aoj/2270/"/>
    <updated>2015-08-08T20:06:20+09:00</updated>
    <id>http://algoogle.hadrori.jp/aoj/2270</id>
    <content type="html"><![CDATA[<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2270">The L-th Number</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>頂点に値が割り当てられてる木について以下のクエリQ個を捌け．</p>

<ul>
  <li>2頂点v,w間のパス上の頂点のうち，l番目に小さいものを出力</li>
</ul>

<h4 id="section-1">解法</h4>

<hr />

<p>全体の方針としては，wavelet行列で列にした木上の2区間(パスをLCAで2つに分割したもの)内のL番目の数字を求める．<br />
全体の計算量は最大値をMとして{% m %}O((Q+N)\log M){% em %}</p>

<p>適当な頂点を根にしてオイラーツアーして木の頂点の値を列にする．またこのときLCAの準備もしておく．<br />
このとき入る時の値の列pと出る時の値の列qを作る．<br />
p,qはpに0でない値が入っている位置はqでは0で，qに0でない値が入っている位置はpでは0になるようにする．<br />
例えばオイラーツアーしてできる頂点番号の列が
<code>
1 2 2 3 4 4 3 1
</code>
だとして，それぞれ値が頂点番号と同じだとしたら
<code>
p : 1 2 0 3 4 0 0 0
q : 0 0 2 0 0 4 3 1
</code>
となる．<br />
このpとqについてのwavelet行列を生成する．<br />
このp，qでパス上の頂点の値の出現回数がわかるようになる．同じ区間で見て，pで増えて，qで減るから．</p>

<p>{% m %}u := LCA(v,w){% em %}とする．<br />
オイラーツアーしてできた列は頂点b,とその祖先a間のパスを，{% m %}[in(a),in(b)]{% em %}と表現できる(途中のいらない部分木は頂点に入るのと出るので打ち消されてる)．<br />
ここで{% m %}in(a){% em %}とは列上で頂点aに入る位置．<br />
あとはこうしてできた2区間{% m %}[in(u),in(v)], [in(u)+1,in(w)]{% em %}上でL番目に小さい値を求めればよい．<br />
あとは1つの区間でK番目に大きいものを求めるものを応用させればよい(詳しくはコードを参照してほしい)．<br />
ざっくり言うと，最上位bitからみて区間内で有効な値のうち1が立ってる数がLより大きいかどうかでwavelet行列の行上の区間を選んでいく．</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code AOJ/2270.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JOI 春合宿 2010 Highway]]></title>
    <link href="http://algoogle.hadrori.jp/joi/sc2010highway/"/>
    <updated>2014-09-19T22:36:03+09:00</updated>
    <id>http://algoogle.hadrori.jp/joi/sc2010highway</id>
    <content type="html"><![CDATA[<p><a href="http://joisc2010.contest.atcoder.jp/tasks/joisc2010_highway">Highway</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>木が与えられる.<br />
ノードの番号が小さい方から大きい方へいく時を上りといい, 逆の時を下りという.<br />
以下のクエリを処理しろ.</p>

<ul>
  <li>ある辺の上りと下りにかかる時間の変更</li>
  <li>ある2頂点x, yのxからyにいくときにかかる時間の総和の出力</li>
</ul>

<h4 id="section-1">解法</h4>

<hr />

<p>根付き木として考える.<br />
頂点uから頂点vまでの距離を求めたい.<br />
上りと下りの区別がないとして考える.<br />
上りと下りの区別がないとき, 2頂点間の距離はその最小共通祖先wまでの距離の和と考えるとよい.<br />
こうするとオイラーツアーしてやれば区間に部分木が入るので, 辺を降りるときに足して昇るときに引いてやればBITで各頂点からその子孫までの距離をO(log n)で得ることができる.<br />
辺の更新はBITで対応する位置に現在の値との差分を足してやれば良い.</p>

<p>上りと下りの区別がある場合<br />
パスの向きを考えるとu-&gt;w-&gt;vと進むことになることが分かる.<br />
もっと詳しく見ると<br />
u-&gt;wが根に向かって進む方向<br />
w-&gt;vが葉に向かって進む方向<br />
この2種類しかないので上りと下りをこれに対応させて2本のBIT, つまり根に向かう方向の距離を求めるのと葉に向かう方向の距離を求めるBITをそれぞれ別に用意すれば良い.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code JOI/2010/highway.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces 379F New Year Tree]]></title>
    <link href="http://algoogle.hadrori.jp/codeforces/379f/"/>
    <updated>2014-07-09T02:04:27+09:00</updated>
    <id>http://algoogle.hadrori.jp/codeforces/379f</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/problemset/problem/379/F">New Year Tree</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>はじめに根1とその3つの子2~4がある.<br />
q(&lt;=5e5)回の以下のクエリを捌け.</p>

<ul>
  <li>頂点vに2つの頂点を加え, 木の直径を答える</li>
</ul>

<h4 id="section-1">解法</h4>

<hr />

<p>木の直径は一番離れた2点の距離.<br />
初期では頂点2, 3の距離が当てはまる.<br />
頂点を追加するたびにその頂点と, 現在の直径で使われている2点の距離をみる.<br />
もし距離が大きくなるなら頂点を交換する.<br />
距離はLCAを求めればよいのでO(log n)で計算可能.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code Codeforces/379F.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces 418D Big Problems for Organizers]]></title>
    <link href="http://algoogle.hadrori.jp/codeforces/418d/"/>
    <updated>2014-06-28T00:32:28+09:00</updated>
    <id>http://algoogle.hadrori.jp/codeforces/418d</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/problemset/problem/418/D">Big Problems for Organizers</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>頂点数n(&lt;=100000)の木が与えられる. この時m回以下のクエリが与えられる.<br />
頂点u, vから最も遠い点との距離はいくらか. ただし距離はu, vからのそれぞれの距離のうち小さい方を使う.</p>

<h4 id="section-1">解法</h4>

<hr />

<p>便宜上適当な頂点を根としておく.<br />
2頂点の中間部分で木を分解すれば, その木の根をそれぞれu, vとすることで木の高さが最長距離に当たる.</p>

<p>クエリのu, vは深さの降順になっているとする.<br />
w = LCA(u,v)とすると, 分割点cはdepth[u] = depth[v]ならw, そうでないならuとwの間にある.</p>

<p>そうするとuを含む方の木は以下の場合分けで高さが求まる.</p>

<ul>
  <li>元の木でuの子孫に最も遠い点がある</li>
  <li>uとcの間にuから最も遠い点がある</li>
</ul>

<p>部分木の高さは各点の深さと一緒に計算すればよい(O(n)).<br />
ここでuとcの間というのは, uの祖先だけでなく, 祖先の子孫も含む(ただしu以下は含まない).<br />
これはdoublingで2の冪個先の祖先までの区間について求めておけばO(log n)で求まる(構築はO(n log n)).<br />
これでuを含む方の木については調べられた.</p>

<p>v(とw)を含む木の方は, 以下の場合分けで求まる</p>

<ul>
  <li>vの子孫に最も遠い点がある</li>
  <li>vとwの間にvまでの最も遠い点がある</li>
  <li>wと根の間にvまでの最も遠い点がある</li>
  <li>vとcの間にvまでの最も遠い点がある</li>
  <li>その他のwの子孫(子供が根になる部分木にv, cを含まない)に最も遠い点がある</li>
</ul>

<p>始めの3つはuの時と同じdoublingで求めてあるやつを使えば良い.<br />
4つ目は今までのと似ているが, 基準の点が祖先の方なので別に用意する(似たようなdoublingをするだけ).<br />
最後は各頂点に対してその頂点を根とする部分木の高さを求めるとき, その子を根とする部分木の高さが最も大きい3つを保存すれば良い.<br />
そのとき子供の番号も保存しておけば, その頂点がvまたはcの祖先にいるかで使うかどうかを決めることができる.</p>

<p>以上をバグらないように実装する.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code Codeforces/418D.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PKU 1986 Distance Queries]]></title>
    <link href="http://algoogle.hadrori.jp/pku/1986/"/>
    <updated>2014-05-04T15:39:09+09:00</updated>
    <id>http://algoogle.hadrori.jp/pku/1986</id>
    <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=1986">Distance Queries</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>全域木になるようなグラフが与えられ, 各枝には重みが付いている.<br />
頂点数はN(&lt;=40,000)<br />
そのとき, K(&lt;=10,000)回クエリが与えられる. 各クエリでは2点が与えられるのでその2点の木の上での距離を答えよ.<br /></p>

<h4 id="section-1">解法</h4>

<hr />

<p>愚直にやると, 各クエリでO(N)かかるので全体でO(NK)で話にならない.<br />
木の上での2点の距離は2点のLCAを仲介にして距離を求めることができる.<br />
DFSで頂点を全てみるときの順番(戻るときも含める)に各点のDFSの深さを保存しておく.<br />
そうすると2点の間の深さの最小を取ってくればそれがLCAになる.<br />
明らかにRMQなのでSegment Treeで実装する.<br />
<br />
また, 各点からその各祖先までの距離もそのDFSの順に求める. 頂点に入るときに辺の重みを足し, 戻るときに引けばBITで区間の距離の総和が出せる(ただし各祖先までの距離しか出せない).<br />
よって2点の距離はそのLCAを介することで求められる.<br />
<br />
DFSの順番について, 例えば以下の図のように探索するとき頂点の列は<br />
1 2 5 2 6 2 1 3 1 4 1<br />
となり, それに対応する深さの列は<br />
0 1 2 1 2 0 1 0 1 0<br />
となり, 各頂点について頂点に入るときの列の場所を覚えておけばその区間を見るだけでよいことがわかる<br /></p>

<p><img src="/images/pku1986-01.png" alt="" /></p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code PKU/1986.cpp %}</p>

]]></content>
  </entry>
  
</feed>
