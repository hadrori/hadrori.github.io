<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: wavelet-matrix | Algoogle]]></title>
  <link href="http://algoogle.hadrori.jp/tags/wavelet-matrix/atom.xml" rel="self"/>
  <link href="http://algoogle.hadrori.jp/"/>
  <updated>2015-12-14T02:08:05+09:00</updated>
  <id>http://algoogle.hadrori.jp/</id>
  <author>
    <name><![CDATA[hadrori]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ 2674 Disordered Data Detection]]></title>
    <link href="http://algoogle.hadrori.jp/aoj/2674/"/>
    <updated>2015-10-18T15:55:39+09:00</updated>
    <id>http://algoogle.hadrori.jp/aoj/2674</id>
    <content type="html"><![CDATA[<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2674">Disordered Data Detection</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>長さDの整数列xがある．<br />
- 閉区間[l,r]にx[i]&lt;min(x[l],x[r])-eまたはmax(x[l],x[r])+e&lt;x[i]となるiの個数を求めよ<br />
というクエリがQ個くるのでそれに答えよ</p>

<h4 id="section-1">解法</h4>

<hr />

<p>データ構造で殴る．具体的にはwavelet行列．<br />
区間[l,r)に値が[a,b)に含まれるような値の個数は最大値をMとすると {% m %}O(\log{M}){% em %}で求められる．<br />
非負数は扱えないので適当に下駄を履かせる．</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code AOJ/2674.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ 2270 The L-th Number]]></title>
    <link href="http://algoogle.hadrori.jp/aoj/2270/"/>
    <updated>2015-08-08T20:06:20+09:00</updated>
    <id>http://algoogle.hadrori.jp/aoj/2270</id>
    <content type="html"><![CDATA[<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2270">The L-th Number</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>頂点に値が割り当てられてる木について以下のクエリQ個を捌け．</p>

<ul>
  <li>2頂点v,w間のパス上の頂点のうち，l番目に小さいものを出力</li>
</ul>

<h4 id="section-1">解法</h4>

<hr />

<p>全体の方針としては，wavelet行列で列にした木上の2区間(パスをLCAで2つに分割したもの)内のL番目の数字を求める．<br />
全体の計算量は最大値をMとして{% m %}O((Q+N)\log M){% em %}</p>

<p>適当な頂点を根にしてオイラーツアーして木の頂点の値を列にする．またこのときLCAの準備もしておく．<br />
このとき入る時の値の列pと出る時の値の列qを作る．<br />
p,qはpに0でない値が入っている位置はqでは0で，qに0でない値が入っている位置はpでは0になるようにする．<br />
例えばオイラーツアーしてできる頂点番号の列が
<code>
1 2 2 3 4 4 3 1
</code>
だとして，それぞれ値が頂点番号と同じだとしたら
<code>
p : 1 2 0 3 4 0 0 0
q : 0 0 2 0 0 4 3 1
</code>
となる．<br />
このpとqについてのwavelet行列を生成する．<br />
このp，qでパス上の頂点の値の出現回数がわかるようになる．同じ区間で見て，pで増えて，qで減るから．</p>

<p>{% m %}u := LCA(v,w){% em %}とする．<br />
オイラーツアーしてできた列は頂点b,とその祖先a間のパスを，{% m %}[in(a),in(b)]{% em %}と表現できる(途中のいらない部分木は頂点に入るのと出るので打ち消されてる)．<br />
ここで{% m %}in(a){% em %}とは列上で頂点aに入る位置．<br />
あとはこうしてできた2区間{% m %}[in(u),in(v)], [in(u)+1,in(w)]{% em %}上でL番目に小さい値を求めればよい．<br />
あとは1つの区間でK番目に大きいものを求めるものを応用させればよい(詳しくはコードを参照してほしい)．<br />
ざっくり言うと，最上位bitからみて区間内で有効な値のうち1が立ってる数がLより大きいかどうかでwavelet行列の行上の区間を選んでいく．</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code AOJ/2270.cpp %}</p>
]]></content>
  </entry>
  
</feed>
