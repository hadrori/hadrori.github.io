<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: topological-sort | Algoogle]]></title>
  <link href="http://algoogle.hadrori.jp/tags/topological-sort/atom.xml" rel="self"/>
  <link href="http://algoogle.hadrori.jp/"/>
  <updated>2015-12-14T02:08:05+09:00</updated>
  <id>http://algoogle.hadrori.jp/</id>
  <author>
    <name><![CDATA[hadrori]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Typical DP Contest R - グラフ]]></title>
    <link href="http://algoogle.hadrori.jp/tdpc/r/"/>
    <updated>2015-09-03T17:03:38+09:00</updated>
    <id>http://algoogle.hadrori.jp/tdpc/r</id>
    <content type="html"><![CDATA[<p><a href="http://tdpc.contest.atcoder.jp/tasks/tdpc_graph">R - グラフ</a></p>

<h4 id="section">問題概要</h4>

<hr />

<h4 id="section-1">解法</h4>

<hr />

<p>まずsccして閉路を潰して，DAGをつくる(潰した閉路の頂点数を重さとする新しい頂点を作る)．<br />
その上でトポロジカルソートしたものを考える．</p>

<p>2本の辺の先端をみるDPをする．<br />
dp[i][j] := 進んでる方の先端の位置がiでもう片方の先端の位置がjのときのそれまでに通った頂点数の最大値</p>

<p>また進む先はそこから到達可能ならどこでもよいが，現在のiより先に進むようにする．<br />
これはiまでの頂点はすでに通った頂点かもしれないため．</p>

<p>また進んだ先の頂点の重さだけ現在の値に足す．<br />
これも途中の頂点にすでに通った頂点があるかもしれないから．きちんと順に更新していけば結果は正しくなる．</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code TDPC/R.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ 2598 Website Tour]]></title>
    <link href="http://algoogle.hadrori.jp/aoj/2598/"/>
    <updated>2015-05-07T22:38:14+09:00</updated>
    <id>http://algoogle.hadrori.jp/aoj/2598</id>
    <content type="html"><![CDATA[<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2598">Website Tour</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>有向グラフ上のノードiでコスト{% m %}t_i{% em %}でポイント{% m %}p_i{% em %}が手に入る．<br />
ノードiでポイントが得られるのは{% m %}k_i{% em %}回まで．ただし同じノードでポイントを得るには1回以上の遷移が必要．<br />
コストの総和がT以内で得られるポイントの総和の最大を求めよ．</p>

<h4 id="section-1">解法</h4>

<hr />

<p>入力のグラフGを強連結成分分解する．各強連結成分を1つのノードとしたDAG(これをHとする)上でDPする．</p>

<p>dp[i][j] := 強連結成分iでコストj以下の時の最大の総ポイント</p>

<p>Hのノードはトポロジカルソートし，順にやればよい．<br />
Hの各ノードでの計算は個数制限ナップサックをすればよい．Hでのノードからノードへの遷移は各コストでのdp表のmaxをとる．<br />
ただしノードがGのノードを1つしか含まず，そのノードも自己ループを持たないときは1回しかそこを通れないので01ナップサック(個数制限を1にしたナップサック)をやる．</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code AOJ/2598.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JOI 春合宿 2011 Orienteering]]></title>
    <link href="http://algoogle.hadrori.jp/joi/sc2011orienteering/"/>
    <updated>2014-10-03T01:03:17+09:00</updated>
    <id>http://algoogle.hadrori.jp/joi/sc2011orienteering</id>
    <content type="html"><![CDATA[<p><a href="http://joisc2011.contest.atcoder.jp/tasks/joisc2011_orienteering">Orienteering</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>始点1, 終点nで頂点1からどの頂点にも到達可能なDAGが与えられる.<br />
K個の頂点をチェックポイントとして指定する.<br />
2人であわせて全てのチェックポイントを通って始点から終点に向かうようなパスの最短距離を求めよ</p>

<h4 id="section-1">解法</h4>

<hr />

<p>まずどの頂点がどの頂点より前に来るか知りたいのでトポロジカルソートする.<br />
続いてチェックポイント以外で止まることに意味はないので, チェックポイントだけのグラフを考えて全点対最短路を求める.<br />
あとはどのように頂点を進んでいくか.</p>

<p>片方がどちらかより先行していて, かつその頂点までのトポロジカル順で前にあるチェックポイントは全て通っているとする.<br />
このときの頂点をそれぞれ順にv, uと置く. またその状態までの最短距離をdp[v][u]と置く.<br />
そうすると次に向かう頂点wはvのトポロジカル順で次のチェックポイントになる.<br />
wにはどちらが進んでも問題ないが先行する方を次のvにするということに注意する.</p>

<p>これに加えてどちらも先行しない, つまりどちらも同じ場所にいる場合も考える.<br />
これは先行する場合の遷移先と, 先行する場合の遷移元に同じ頂点にいる場合を付け加えるだけで良い.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code JOI/2011/orienteering.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JOI 春合宿 2008 Sheet]]></title>
    <link href="http://algoogle.hadrori.jp/joi/sc2008sheet/"/>
    <updated>2014-09-04T02:04:22+09:00</updated>
    <id>http://algoogle.hadrori.jp/joi/sc2008sheet</id>
    <content type="html"><![CDATA[<p><a href="http://joisc2008.contest.atcoder.jp/tasks/joisc2008_sheet">Sheet</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>紙をいくつか置いてある.<br />
それを上から見たものが与えられるので, どのような順に置いたか考えられるものを1つ出力しろ.</p>

<h4 id="section-1">解法</h4>

<hr />

<p>紙の上下関係を有向グラフにしてトポロジカルソートすればよい.<br />
ある紙の上にどの紙が存在するかは, その紙をちょうど含むような長方形を求めてその長方形上に乗っているものを調べれば分かる.</p>

<p>トポロジカルソートとは閉路のない有向グラフの順番付けに関するソート.<br />
ある頂点がその先にあるどの頂点よりも先に来るようなソートの仕方で, これは逆グラフをdfsでたどるときの後順(postorder)を考えれば良い.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code JOI/2008/Sheet.cpp %}</p>
]]></content>
  </entry>
  
</feed>
