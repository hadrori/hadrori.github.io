<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: sqrt-decomposition | Algoogle]]></title>
  <link href="http://algoogle.hadrori.jp/tags/sqrt-decomposition/atom.xml" rel="self"/>
  <link href="http://algoogle.hadrori.jp/"/>
  <updated>2015-07-30T15:13:28+09:00</updated>
  <id>http://algoogle.hadrori.jp/</id>
  <author>
    <name><![CDATA[hadrori]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Code Festival 2014 Exibition B カッコつけ]]></title>
    <link href="http://algoogle.hadrori.jp/codefestival/cf2014exb/"/>
    <updated>2014-11-11T21:26:10+09:00</updated>
    <id>http://algoogle.hadrori.jp/codefestival/cf2014exb</id>
    <content type="html"><![CDATA[<p><a href="http://code-festival-2014-exhibition-open.contest.atcoder.jp/tasks/code_festival_exhibition_b">カッコつけ</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>開き括弧と閉じ括弧からなる文字列がある.<br />
Q個のクエリが与えられるので処理しろ.<br />
クエリは以下のいずれか</p>

<ul>
  <li>1箇所削除</li>
  <li>’(‘を挿入</li>
  <li>’)’を挿入</li>
  <li>区間[l,r]の部分文字列について, balancedにするのに削除する最小の数</li>
</ul>

<h4 id="section-1">解法</h4>

<hr />

<p>解説スライド<a href="http://www.slideshare.net/chokudai/codefestival2014ex">CODE FESTIVAL 2014 エキシビジョン 解説</a><br />
スライドでは式が唐突に出てきていたのでそこを中心に書く.<br />
また解法は平方分割しか書いてないので平衡二分探索木についても少し.</p>

<p>とりあえず’(‘を+1, ‘)’を-1として累積和を考える.<br />
区間の先頭の値(加算前)をx, 区間の最小値をy, 区間の末尾の値(加算後)をzとする.<br />
yがx未満であるとき, 負になる分の’)’をyの位置以前で取り除くことで最小値を非負にできる. またこれが最適なのは自明. <br />
次にzがxより大きい場合, それ以前の’(‘を末尾に近いものから取り除くことでbalancedにできる. これが最適なのも自明.<br />
つまり必要な数は</p>

<p>{% math %}</p>

<p>(x-y)+((z+(x-y))-x) = x-2y+z</p>

<p>{% endmath %}</p>

<p>となる. 最小値yはx以下, 始めの操作後はzがz+x-yとなりこれはx以上なので常にこれが成り立つ.<br />
あとは区間addと区間minをとれる平衡二分探索木に投げるだけ.<br />
平方分割に対して平衡二分探索木が実装がつらいというのは誤解で, どうせ人々は平衡二分探索木のライブラリを持っていて, 今回の問題に対応するような拡張はかなり一般的で難しくない(というか持っている人も多いと思う).<br />
区間addは遅延評価, 区間minはsegtreeのRMQみたいなかんじでやればよい.<br />
遅延評価でやれば回転とかをややこしく考えなくて良い.<br />
コードは赤黒木だがTreapとかならもっと単純で良い.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code CodeFestival/2014/exhibition/b.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JOI 春合宿 2008 Typhoon]]></title>
    <link href="http://algoogle.hadrori.jp/joi/sc2008typhoon/"/>
    <updated>2014-09-04T17:27:48+09:00</updated>
    <id>http://algoogle.hadrori.jp/joi/sc2008typhoon</id>
    <content type="html"><![CDATA[<p><a href="http://joisc2008.contest.atcoder.jp/tasks/joisc2008_typhoon">Typhoon</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>n個の台風の被害にあった区間[s,t]の情報が与えられる.<br />
地点pに台風q号からr号までで被害にあった回数を答えるクエリm個を捌け</p>

<h4 id="section-1">解法</h4>

<hr />

<p>まず場所の範囲が大きいのでクエリで聞かれる場所だけで座標圧縮する.</p>

<p>n個の台風を平方分割する.<br />
分割された部分までの台風の情報をまとめて累積で持つ.<br />
分割部分からはみ出た部分はナイーブに計算する.<br />
分割部分はBITで持つことにする.</p>

<p>TLE厳し目なうえ, 分割数によってはMLEも厳しいのでsegreeを使う場合は気をつける</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code JOI/2008/Typhoon.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces 446C DZY Loves Fibonacci Numbers]]></title>
    <link href="http://algoogle.hadrori.jp/codeforces/446c/"/>
    <updated>2014-07-14T00:34:37+09:00</updated>
    <id>http://algoogle.hadrori.jp/codeforces/446c</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/problemset/problem/446/C">DZY Loves Fibonacci Numbers</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>長さn(&lt;=300000)の数列aと, Fibonacci数列fを考えるとき以下のクエリを処理しろ.</p>

<ul>
  <li>aの区間[l,r]の要素a[i]にそれぞれf[i-l]を加える</li>
  <li>aの区間[l,r]の要素の合計値をmod 1e9+9で答える</li>
</ul>

<h4 id="section-1">解法</h4>

<hr />

<p>分割の大きさをBとして平方分割する.<br />
加えるときは分割された区間を覆う場合は一気に足すのと端っこが余った場合はナイーブにaに足していく.<br />
またいままで区間に足されたFibonacci数の始め2項をそれぞれ和として保存しておく.</p>

<p>復元するときは分割された区間を覆う場合はその部分は一気に足し合わせる.<br />
端っこの余った部分はナイーブにaを足し合わせるのと, その区間に一気に足し合わせたFibonacci数の始めの2項のそれぞれの総和から各aに一気に足されたFibonacci数を復元する.<br />
{% m %} a_i {% em %}に足されたFibonacci数の総和の復元はj番目のFibonacci数を{% m %}F_j{% em %}とし, その区間に一気に足されたFibonacci数の最初の2項のそれぞれの総和をu, vとすると<br />
{% math %} 
    uF_{i-2}+vF_{i-1}
{% endmath %}
でできる.<br />
あとはこれでは微妙にTLEしまくるので分割の大きさとか定数倍高速化とか頑張る(恐らく平方分割は想定解法でなくTLEするようになっている)</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code Codeforces/446C.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces 375D Tree and Queries]]></title>
    <link href="http://algoogle.hadrori.jp/codeforces/375d/"/>
    <updated>2014-07-11T00:03:57+09:00</updated>
    <id>http://algoogle.hadrori.jp/codeforces/375d</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/problemset/problem/375/D">Tree and Queries</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>N(&lt;=100000)頂点の木の各頂点に色が塗られている. このとき以下のクエリに答えろ.<br />
頂点vの部分木にk個以上に塗られている色はいくつあるか</p>

<h4 id="section-1">解法</h4>

<hr />

<p>オイラーツアーして平方分割する.<br />
部分木の開始点を平方分割の各バケットの要素数Bごとに区切る.<br />
クエリをその開始点順にソートし, 同じバケットでは終了点順でソートしておくと開始点の各バケットでの移動は高々B回(オイラーツアーをしているので).<br />
また各バケットでのクエリの終了点の移動は高々N回になる.<br />
よって全体では{% m %}O(N\sqrt{M}){% em %}になる.</p>

<p>データ構造をマージする一般的なテクも使えるらしいのでコードを載せておいた.<br />
深い順にクエリを処理することで順にマージしていけるようにする.<br />
マージは大きいものを選んでそれに小さい方を愚直に突っ込んでいるだけ(直感的にはすごくTLEしそうな感じだ).<br />
マージ後の小さい方はclearしておかないとたぶんMLEする.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code Codeforces/375D.cpp %}</p>

<p>{% include_code Codeforces/375D1.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ 2527 MLE]]></title>
    <link href="http://algoogle.hadrori.jp/aoj/2527/"/>
    <updated>2014-05-26T18:58:35+09:00</updated>
    <id>http://algoogle.hadrori.jp/aoj/2527</id>
    <content type="html"><![CDATA[<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2527">MLE</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>擬似乱数を生成するコードがある.<br />
これによって初期値x0でn個の乱数を生成するときk番目の値はいくらか.</p>

<h4 id="section-1">解法</h4>

<hr />

<p>生成される乱数を適当な大きさの区間で分ける.<br />
そうするとk番目の値を含む区間がわかるので, もう一度乱数を生成して求めた区間の数だけ集める.<br />
あとはそれをソートしてやればk番目の値がわかる.<br />
10^8ぐらいの計算量になるが操作が軽いので問題なく間にあう.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code AOJ/2527.cpp %}</p>
]]></content>
  </entry>
  
</feed>
