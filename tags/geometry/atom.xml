<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: geometry | Algoogle]]></title>
  <link href="http://algoogle.hadrori.jp/tags/geometry/atom.xml" rel="self"/>
  <link href="http://algoogle.hadrori.jp/"/>
  <updated>2015-12-14T02:08:05+09:00</updated>
  <id>http://algoogle.hadrori.jp/</id>
  <author>
    <name><![CDATA[hadrori]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ 2597 Color the Map Extreme]]></title>
    <link href="http://algoogle.hadrori.jp/aoj/adventcalendar/2597/"/>
    <updated>2015-12-14T00:32:26+09:00</updated>
    <id>http://algoogle.hadrori.jp/aoj/adventcalendar/2597</id>
    <content type="html"><![CDATA[<p>AOJ-ICPC Advent Calendar 2015の14日目の記事です．</p>

<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2597">Color the Map Extreme</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>平面上にn(&lt;=35)個多角形がある．彩色数を求めよ．</p>

<h4 id="section-1">解法</h4>

<hr />

<p>幾何パートは辺同士で線分と点の距離が0になる個数と端点がくっついてるかでみてます．</p>

<ul>
  <li>2個より多い: 辺がくっついてる</li>
  <li>2個で端点がくっついてない: 辺がくっついてる</li>
  <li>それ以外: 辺がくっついてない</li>
</ul>

<p>グラフができたら彩色数を求めます．<br />
まず大前提として，できたグラフは平面グラフなので彩色数は最大でも4なので，グラフから極大独立集合を取ってきてそこの色を決めたら残りの部分は3色以下で塗れます．<br />
極大独立集合とは互いに隣り合わない頂点の集合(独立集合)のうち，これ以上頂点を追加できないものです．<br />
残ったグラフでは頂点がなければ0色，辺がなければ1色，2部グラフなら2色，それ以外なら3色とわかるので適当に塗っていけば何色で塗れるかわかります．<br />
つまり極大独立集合を全列挙して試せばグラフの彩色数がわかります．</p>

<p>極大独立集合は貪欲にやっていけば求まりますが，列挙する場合は最小次数の頂点かその隣接する頂点を選ぶかでやるといい感じになります．<br />
もうちょっとだけ詳しく書こうとしたけどわかりづらくなったので擬似コード．詳しくはコード見て下さい(FCCPCのチームライブラリから取ってきたので僕が書いたわけではありませんが)．<br />
前提条件として，SとTは空，Vはグラフの頂点集合が入ってます．事後条件はTは全ての極大独立集合の集合．</p>

<p>&#8220;`
set: S, T, V</p>

<p>func f
  if Vが空 then
    TにSを追加
  else then
    v = Vにある頂点のうち最小次数の頂点1つ
    Vからvとその近傍を取り除く(1)
    Sにvを入れる
    call f
    Sからvを取り除く
    Vに(1)で取り除いた頂点を戻す
    for w in Vにある頂点のうちvに隣接する頂点
      Vからwとその近傍を取り除く(2)
      Sにwを入れる
      call f
      Sからwを取り除く
      Vに(2)で取り除いた頂点を戻す
    end
  end
end
&#8220;`</p>

<p>極大独立集合は最小の次数をkとしたとき (k+1)^(n/(k+1)){% em %} 個できる．これはk+1=eのとき最大になるが，kは整数なのでk+1=3の時が最大．<br />
1つの極大独立集合を見つけるのにO(n)なので，列挙の計算量はO(n3^(n/3))となります．<br />
ちなみにグラフによってはこのアルゴリズムは一部の極大独立集合を重複して列挙しますが，それを含めた計算量．</p>

<p>極大独立集合を除いたグラフでの彩色数のチェックにはそれぞれO(n)かかるので，全体の計算量もO(n3^(n/3)){% em %} となります．<br />
35*3^(35/3)は10^7ぐらいなので間に合います．</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code AOJ/2597.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ 2597 Color the Map Extreme]]></title>
    <link href="http://algoogle.hadrori.jp/aoj/2597/"/>
    <updated>2015-12-14T00:32:26+09:00</updated>
    <id>http://algoogle.hadrori.jp/aoj/2597</id>
    <content type="html"><![CDATA[<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2597">Color the Map Extreme</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>平面上にn(&lt;=35)個多角形がある．彩色数を求めよ．</p>

<h4 id="section-1">解法</h4>

<hr />

<p>幾何パートは辺同士で線分と点の距離が0になる個数と端点がくっついてるかでみてます．</p>

<ul>
  <li>2個より多い: 辺がくっついてる</li>
  <li>2個で端点がくっついてない: 辺がくっついてる</li>
  <li>それ以外: 辺がくっついてない</li>
</ul>

<p>グラフができたら彩色数を求めます．<br />
まず大前提として，できたグラフは平面グラフなので彩色数は最大でも4なので，グラフから極大独立集合を取ってきてそこの色を決めたら残りの部分は3色以下で塗れます．<br />
極大独立集合とは互いに隣り合わない頂点の集合(独立集合)のうち，これ以上頂点を追加できないものです．<br />
残ったグラフでは頂点がなければ0色，辺がなければ1色，2部グラフなら2色，それ以外なら3色とわかるので適当に塗っていけば何色で塗れるかわかります．<br />
つまり極大独立集合を全列挙して試せばグラフの彩色数がわかります．</p>

<p>極大独立集合は貪欲にやっていけば求まりますが，列挙する場合は最小次数の頂点かその隣接する頂点を選ぶかでやるといい感じになります．<br />
もうちょっとだけ詳しく書こうとしたけどわかりづらくなったので擬似コード．詳しくはコード見て下さい(FCCPCのチームライブラリから取ってきたので僕が書いたわけではありませんが)．<br />
前提条件として，SとTは空，Vはグラフの頂点集合が入ってます．事後条件はTは全ての極大独立集合の集合．</p>

<p>&#8220;`
set: S, T, V</p>

<p>func f
  if Vが空 then
    TにSを追加
  else then
    v = Vにある頂点のうち最小次数の頂点1つ
    Vからvとその近傍を取り除く(1)
    Sにvを入れる
    call f
    Sからvを取り除く
    Vに(1)で取り除いた頂点を戻す
    for w in Vにある頂点のうちvに隣接する頂点
      Vからwとその近傍を取り除く(2)
      Sにwを入れる
      call f
      Sからwを取り除く
      Vに(2)で取り除いた頂点を戻す
    end
  end
end
&#8220;`</p>

<p>極大独立集合は最小の次数をkとしたとき {% m %}(k+1)^{\frac{n}{k+1}}{% em %} 個できる．これはk+1=eのとき最大になるが，kは整数なのでk+1=3の時が最大．<br />
1つの極大独立集合を見つけるのに {% m %}O(n){% em %} なので，列挙の計算量は {% m %}n3^{\frac{n}{3}}{% em %}となる．<br />
ちなみにグラフによってはこのアルゴリズムは一部の極大独立集合を重複して列挙しますが，それを含めた計算量です．</p>

<p>極大独立集合を除いたグラフでの彩色数のチェックにはそれぞれ {% m %}O(n){% em %} かかるので，全体の計算量も {% m %}O(n3^{\frac{n}{3}}){% em %} となる．<br />
35*3^(35/3)は10^7ぐらいなので間に合います．</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code AOJ/2597.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ 1266 How I Wonder What You Are!]]></title>
    <link href="http://algoogle.hadrori.jp/aoj/1266/"/>
    <updated>2015-10-18T15:24:24+09:00</updated>
    <id>http://algoogle.hadrori.jp/aoj/1266</id>
    <content type="html"><![CDATA[<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1266">How I Wonder What You Are!</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>原点からの向きと角度がいくつか与えられるので，その範囲にある点の数を求めよ．</p>

<h4 id="section-1">解法</h4>

<hr />

<p>望遠鏡と，原点から星までの直線の成す角を求めて比較すれば良い</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code AOJ/1266.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ 1242 Area of Polygons]]></title>
    <link href="http://algoogle.hadrori.jp/aoj/1242/"/>
    <updated>2015-05-06T12:44:07+09:00</updated>
    <id>http://algoogle.hadrori.jp/aoj/1242</id>
    <content type="html"><![CDATA[<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1242">Area of Polygons</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>頂点が格子点上にある多角形が与えられる．<br />
多角形が通るマスと多角形に含まれるマスの数を答えよ．</p>

<h4 id="section-1">解法</h4>

<hr />

<p>y軸に平行な太さが1マス分の走査線で平面走査する．<br />
各線分から現在見てる区間を切り取って，左側のx座標でソートする．<br />
あとは足される区間と足さない区間が交互にくるので足してやればいい．<br />
y軸に平行な線分は無視．</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code AOJ/1242.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PA 2010 Sweets]]></title>
    <link href="http://algoogle.hadrori.jp/pa/pa2010sweets/"/>
    <updated>2014-11-01T22:15:50+09:00</updated>
    <id>http://algoogle.hadrori.jp/pa/pa2010sweets</id>
    <content type="html"><![CDATA[<p><a href="http://main.edu.pl/en/archive/pa/2010/cuk">Sweets</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>n(&lt;=24)個の箱にそれぞれ{% m %}a_{i}{% em %}個のお菓子がある.<br />
これを3人兄弟Anton, Dmytro, Borysで箱ごとに配りたい.<br />
できるだけ平等に分けるとき最小のAntonとBorysのもらう数の差を求めよ.<br />
ただしそれぞれのもらう数A, D, Bは{% m %} A \geq D \geq B{% em %}を満たさなければならない.</p>

<h4 id="section-1">解法</h4>

<hr />

<p>まずn個の箱を半分ずつ({% m %}n_{0},n_{1}{% em %})に分ける.<br />
これは半分ずつ全列挙することで全体で全列挙するのを抑えるため.<br />
それぞれの集合で3人がもらう数を{% m %}A_{i}, D_{i}, B_{i}{% em %}とする.<br />
{% m %}(A_{i}, D_{i}, B_{i}){% em %}のありうる組を全列挙しておく.<br />
列挙した組の集合をそれぞれ{% m %}K_{0}, K_{1}{% em %}とする.</p>

<p>ここで以下のような変換{% m %}K_{i} \rightarrow K’_{i}{% em %}をする.</p>

<p>{% math %}</p>

<p>K_{0} \rightarrow K’<em>{0}<br />
(A</em>{0}, D_{0}, B_{0}) \in K_{0} \rightarrow (A_{0}-D_{0}, D_{0}-B_{0}) \in K’<em>{0}<br />
<br />
K</em>{1} \rightarrow K’<em>{1}<br />
(A</em>{1}, D_{1}, B_{1}) \in K_{1} \rightarrow (D_{1}-A_{1}, B_{1}-D_{1}) \in K’_{1}\</p>

<p>{% endmath %}</p>

<p>これによって求める最小値は{% m %}K’<em>{0}, K’</em>{1}{% em %}の要素{% m %}(x_{0},y_{0}), (x_{1},y_{1}){% em %}について</p>

<p>{% math %}</p>

<p>(x_{0}+y_{0})-(x_{1}+y_{1})</p>

<p>{% endmath %}</p>

<p>の最小値となる.<br />
ただし{% m %}x_{0}\geq x_{1}, y_{0}\geq y_{1}{% em %}を満たす組のみ.<br />
なぜなら</p>

<p>{% math %}</p>

<p>A_{0}+A_{1} \leq D_{0}+D_{1}<br />
A_{0}-D_{0} \leq D_{1}-A_{1}<br />
<br />
D_{0}+D_{1} \leq B_{0}+B_{1}<br />
D_{0}-B_{0} \leq B_{1}-D_{1}\</p>

<p>{% endmath %}</p>

<p>を満たさなければならないから.</p>

<p>この条件から2次元上の最近点(マンハッタン距離)を求めれば良い.<br />
条件より{% m %}K’<em>{0}{% em %}の点を固定してと考えると, 最も近い{% m %}K’</em>{1}{% em %}の条件を満たす点というのは<br />
それより左下にあるもののうち, x+yが最大になる点とわかる.<br />
これは2つの集合の点を混ぜてyの昇順に見ていけば<br />
{% m %}K’<em>{0}{% em %}の点pのとき, それまでに出てきた{% m %}K’</em>{1}{% em %}の点のうちx座標についてp以下にあって, x+yが最大に点が一番近い.<br />
{% m %}K’_{1}{% em %}の点pのとき, 登場済みリストに入れる. ただしx座標についてそれ以降の点でx+yの値ががp以下のものは選ばれることが無い(もしくはそれを選ぶ必要がない)ので予め削除する.</p>

<p>2つ目の操作から登場済みリストはxについて単調増加であり, またx+yについて単調非減少になる.<br />
これの性質を利用することで1つ目の操作はx座標についてp以下のもののうち一番近いものを2分探索で選べばよく, 2つ目の操作はx座標についてp以上かつx+yについてp以下の点の区間を2分探索で求め削除することができる.</p>

<p>計算量は列挙に{% m %}O(3^{n/2}) = O(\sqrt{3}^{n}){% em %}, 各操作に{% m %}O(\log \sqrt{3}^{n}){% em %}となる.<br />
よって全体では{% m %}O(\sqrt(3)^{n}n) = O(1.74^{n}){% em %}となりなんとか間に合う.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code PA/2010/sweets.cpp %}</p>
]]></content>
  </entry>
  
</feed>
