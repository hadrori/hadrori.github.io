<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: greedy | Algoogle]]></title>
  <link href="http://algoogle.hadrori.jp/tags/greedy/atom.xml" rel="self"/>
  <link href="http://algoogle.hadrori.jp/"/>
  <updated>2015-12-14T02:08:05+09:00</updated>
  <id>http://algoogle.hadrori.jp/</id>
  <author>
    <name><![CDATA[hadrori]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ 2236 Rabbit Plays Games!]]></title>
    <link href="http://algoogle.hadrori.jp/aoj/2236/"/>
    <updated>2015-04-30T14:06:26+09:00</updated>
    <id>http://algoogle.hadrori.jp/aoj/2236</id>
    <content type="html"><![CDATA[<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2236">Rabbit Plays Games!</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>自分とn体の敵がいる．<br />
それぞれHP，攻撃力，防御力，素早さのステータスをもつ．<br />
それぞれ素早さが高い順に攻撃できる．<br />
攻撃力がaのキャラが防御力dのキャラに攻撃して与えるダメージはmax(0,a-d)である．<br />
自分が受けるダメージの最小を答えよ．<br />
ただしそれが自分のHPより大きい場合は-1を出力せよ．</p>

<h4 id="section-1">解法</h4>

<hr />

<p>倒していく順番を考える．<br />
敵iを倒すのにかかるターン数をAi, 1回あたり食らうダメージをBiとする．<br />
敵iを倒して，敵jを残す時，敵jから食らうダメージがAi*Bjだけ増える．<br />
逆の順ならAj*Biだけ増える．<br />
この増加量の大小関係は推移する．<br />
これは各値は正とすれば<br />
Ai*Bj &lt; Aj*Bi<br />
なら両辺をBi，Bjで割れば<br />
Ai/Bi &lt; Aj/Bj<br />
となり明らか．<br />
これが小さくなる順に倒せば良い．</p>

<p>ただし，自分が相手にダメージを与えられない場合と，相手が自分にダメージを与えられない場合に留意すること．</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code AOJ/2236.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PA 2010 Termites]]></title>
    <link href="http://algoogle.hadrori.jp/pa/pa2010termites/"/>
    <updated>2014-11-09T22:48:12+09:00</updated>
    <id>http://algoogle.hadrori.jp/pa/pa2010termites</id>
    <content type="html"><![CDATA[<p><a href="http://main.edu.pl/en/archive/pa/2010/ter">Termites</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>長さnの数列aがある.<br />
今, 0に隣接した正の数を0にかえてその分の値をスコアとして得る.<br />
これを2人で交互に繰り返す.<br />
どちらも最適な行動を取るとき得られるスコアの総和を2人分求めよ.</p>

<h4 id="section-1">解法</h4>

<hr />

<p>問題の操作はstackとdequeがいくつかあって, そのいずれかでpopしていくかんじ.<br />
以降stackは配列の右側がtopで, 単調増加とかは左から右に見た時のことを指しているとする.<br />
こういうゲームは自分が相手よりいくら勝っているかを考えると考えやすいことが多い.<br />
前処理として数字をうまくマージすることでgreedyに落とすことができる.</p>

<p>どういうときにgreedyでできるか考える.<br />
まずはdequeが1つの場合.<br />
列が単調であれば取る方は大きい方でよい.<br />
なぜなら偶数個であれば1個飛ばしで得られる列の大きいほうが得られ, 奇数個であればそれに一番小さい値が加わるだけだから.<br />
そのようなdequeが2つ以上の場合は？<br />
アクセス可能なところのうち大きい方から取ればよい.<br />
2つの場合を考えると最適な取り方は片方に単調性が崩れないようにもう片方を適当な位置に挿入したになるため.</p>

<p>もう少しdequeを詰める.<br />
dequeだけど大きい方しか見てないことと2つ以上あっても動き方は変わらない.<br />
つまりdeque内の列が谷型でもよいということ(使わない小さい方を潰す).<br />
列を谷型に直すのは単調に直すのより簡単(山になってる部分をマージする).</p>

<p>3つ並んだ数字x, y, zについて, {% m %}x \leq y, z \leq y{% em %}を満たすときを考える.<br />
この部分のxにアクセス可能なとき, これを取ると相手がyを取る.<br />
これだけでは損だけでつらいのでzを取る(xを取らざるを得なかった状況でも当然zを取ることになる).<br />
つまりxを取るとは相手よりx+y-zだけ多く得ると考えることができるので, x, y, zをx+y-zに置き換える.<br />
これは多重にやってもいい. なぜなら置き換えた後はただの1つの数字だから.<br />
また適用する順序は関係ない.<br />
なぜならv, w, x, y, zとあるとき(条件は今は無視する),<br />
v, w, xをマージするとv-w+x, y, zとなる. これをマージするとv-w+x-y+zとなる.<br />
x, y, zをマージするとv, w, x-y+zとなる. これをマージするとv-w+x-y+zとなる.<br />
w, x, yをマージするとv, w-x+y, zとなる. これをマージするとv-w+x-y+zとなる.</p>

<p>deque部分はこれでgreedyにできる！</p>

<p>stack部分は？<br />
山部分が潰せるのは同じ.<br />
それが単調非減少ならdequeの単調なものと同じ.<br />
谷の形は前半がdequeと同じ.<br />
つまりあとは単調減少になってる部分.</p>

<p>最後の2個x, y({% m %}x \geq y{% em %})を考える.<br />
片方がyを取ったとき, 相手はxを取るのが最善.<br />
なぜなら何もせずにx-yの差をつけることができるから.<br />
つまりどちらもこの最後の2個は他に取れるのがなくなるまで取らない.<br />
よって最初の個数の偶奇でどっちがとるか分かる(2個なので毎回同じ人が損する).<br />
もっと言うと初期の個数だけで決まるということは最初に取り除いて良い.<br />
これを繰り返すと単調減少になってる部分は消せる.</p>

<p>これであとはアクセス可能な部分の値でgreedyにできる.<br />
priority queueに突っ込んでやりましょう.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code PA/2010/termites.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[POI III Rooks]]></title>
    <link href="http://algoogle.hadrori.jp/poi/poi3rooks/"/>
    <updated>2014-11-03T15:37:46+09:00</updated>
    <id>http://algoogle.hadrori.jp/poi/poi3rooks</id>
    <content type="html"><![CDATA[<p><a href="http://main.edu.pl/en/archive/oi/3/wie">Rooks</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>n*nのチェス盤にルークをn個置く.<br />
ただし各ルークは他のルークから取れる位置に置かれない(Nクイーン問題の簡易版).<br />
今各ルークを置く位置の範囲を矩形で与えられる.<br />
それを満たすような置き方があるならそれを求めよ.<br />
存在しないならNIEと出せ</p>

<h4 id="section-1">解法</h4>

<hr />

<p>横と縦を分けて考えることができる.<br />
なぜならどの行, 列にもただひとつルークが存在するような置き方をし, 縦と横だけで区間が決まっているため.<br />
よって以下の操作を縦と横でやって合わせればよい.</p>

<p>位置iについて, そこから始まる区間の終端とidの組を候補リストに加える.<br />
もし位置iより右端が大きい候補が存在しなければ位置iに対応するルークが存在しないのでNIE<br />
存在するならそのうち右端が一番小さいルークを置く.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code POI/III/rooks.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PA 2010 Mashrooms]]></title>
    <link href="http://algoogle.hadrori.jp/pa/pa2010mashrooms/"/>
    <updated>2014-10-30T23:25:53+09:00</updated>
    <id>http://algoogle.hadrori.jp/pa/pa2010mashrooms</id>
    <content type="html"><![CDATA[<p><a href="http://main.edu.pl/en/archive/pa/2010/grz">Mashrooms</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>きのこが生えてる場所がn個1列に並んでいる.<br />
各位置には{% m %}a_{i}{% em %}個のきのこが生えてる.<br />
きのこは収穫から2単位時間で再び生える.<br />
となりの場所にいくのに1単位時間かかるとき, 時間t以内に最大何個きのこを採れるか.<br />
開始地点は0番目, 終了はどこでも良い.</p>

<h4 id="section-1">解法</h4>

<hr />

<p>最適な動きをしているときに戻る場合というのを考える.<br />
戻る場所から進んできているので次も必ず進む.<br />
そこで前に戻っているので次も必ず戻る…<br />
と必ず2箇所でループするはず.</p>

<p>よってそれまでの合計を初めから順に見て各位置でそこからループした場合の合計値を出す.<br />
注意するのはn=1の場合そこに留まり続けるので2回に1回加算されるというのを初期値にしておくこと.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code PA/2010/mashrooms.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ACM-ICPC Tokyo Regional 2014 A Bit String Reordering]]></title>
    <link href="http://algoogle.hadrori.jp/icpc/icpc2014tokyoa/"/>
    <updated>2014-10-24T03:06:39+09:00</updated>
    <id>http://algoogle.hadrori.jp/icpc/icpc2014tokyoa</id>
    <content type="html"><![CDATA[<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/cdescription.jsp?cid=ICPCOOC2014&amp;pid=A">Automotive Navigation</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>目標のビット列が与えられる.
今現在のビット列から隣同士を最小何回swapさせれば目標のビット列になるか.
ただし元の列は0と1どちらかわからない(どちらかが何個続くという情報の列が与えられる).
元の列から目標の列は生成可能.</p>

<h4 id="section-1">解法</h4>

<hr />

<p>左から詰めていけばよい.<br />
現在のビットが目標と違ったらそれより先にあるもののうち最初に現れる目標の値の場所とswapし, その距離をコストとする.<br />
その間に目標と違う値が敷き詰められているので目標の値を順にswapさせてきても影響がないためそれで問題ない.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code ICPC/2014/Tokyo/A.cpp %}</p>
]]></content>
  </entry>
  
</feed>
