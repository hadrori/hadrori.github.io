<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: tree | Algoogle]]></title>
  <link href="http://algoogle.hadrori.jp/tags/tree/atom.xml" rel="self"/>
  <link href="http://algoogle.hadrori.jp/"/>
  <updated>2015-07-30T15:13:28+09:00</updated>
  <id>http://algoogle.hadrori.jp/</id>
  <author>
    <name><![CDATA[hadrori]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JOI 春合宿 2007 SALT TREE XV]]></title>
    <link href="http://algoogle.hadrori.jp/joi/sc2007salt/"/>
    <updated>2014-08-26T21:37:51+09:00</updated>
    <id>http://algoogle.hadrori.jp/joi/sc2007salt</id>
    <content type="html"><![CDATA[<p><a href="http://joisc2007.contest.atcoder.jp/tasks/joisc2007_salt">SALT TREE XV</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>木が与えられる. 2人のプレイヤーは交互に以下のいずれかの操作をし, 最初に操作ができなくなった方が負ける. 先手は必ず勝てるので, AIに必ず勝つプログラムを書け.</p>

<ul>
  <li>まだ取られていない頂点を1つ取る. この際その頂点に張られている辺も取られる.</li>
  <li>まだ取られていない辺を1つ取る.</li>
</ul>

<h4 id="section-1">解法</h4>

<hr />

<p>相手の番に辺の数も頂点の数も偶数になるように頂点か辺を取れば良い.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code JOI/2007/Salt.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces 455C Civilization]]></title>
    <link href="http://algoogle.hadrori.jp/codeforces/455c/"/>
    <updated>2014-08-09T15:55:12+09:00</updated>
    <id>http://algoogle.hadrori.jp/codeforces/455c</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/455/problem/C">Civilization</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>森が与えられるので以下のクエリを処理しろ.</p>

<ul>
  <li>頂点xの属する木の直径を出力する</li>
  <li>頂点xとyが属する木を直径が最小になるようにマージする</li>
</ul>

<h4 id="section-1">解法</h4>

<hr />

<p>木の直径はある頂点vから一番遠い頂点uをもとめ(vはなんでもよい), uから一番遠い頂点までの距離.<br />
各頂点がどの木に属するかはunion-findで管理すれば良い.<br />
マージの仕方は, 両方の木の直径になるパスの真ん中を繋げば良い.<br />
マージされた木の直径はmax(diam[x], diam[y], (diam[x]+1)/2+(diam[y]+1)/2+1)になる.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code Codeforces/455C.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces 375D Tree and Queries]]></title>
    <link href="http://algoogle.hadrori.jp/codeforces/375d/"/>
    <updated>2014-07-11T00:03:57+09:00</updated>
    <id>http://algoogle.hadrori.jp/codeforces/375d</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/problemset/problem/375/D">Tree and Queries</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>N(&lt;=100000)頂点の木の各頂点に色が塗られている. このとき以下のクエリに答えろ.<br />
頂点vの部分木にk個以上に塗られている色はいくつあるか</p>

<h4 id="section-1">解法</h4>

<hr />

<p>オイラーツアーして平方分割する.<br />
部分木の開始点を平方分割の各バケットの要素数Bごとに区切る.<br />
クエリをその開始点順にソートし, 同じバケットでは終了点順でソートしておくと開始点の各バケットでの移動は高々B回(オイラーツアーをしているので).<br />
また各バケットでのクエリの終了点の移動は高々N回になる.<br />
よって全体では{% m %}O(N\sqrt{M}){% em %}になる.</p>

<p>データ構造をマージする一般的なテクも使えるらしいのでコードを載せておいた.<br />
深い順にクエリを処理することで順にマージしていけるようにする.<br />
マージは大きいものを選んでそれに小さい方を愚直に突っ込んでいるだけ(直感的にはすごくTLEしそうな感じだ).<br />
マージ後の小さい方はclearしておかないとたぶんMLEする.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code Codeforces/375D.cpp %}</p>

<p>{% include_code Codeforces/375D1.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces 382D Ksenia and Pawns]]></title>
    <link href="http://algoogle.hadrori.jp/codeforces/382d/"/>
    <updated>2014-07-09T23:48:22+09:00</updated>
    <id>http://algoogle.hadrori.jp/codeforces/382d</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/382/problem/D">Ksenia and Pawns</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>盤上に向きが指定されているマスがある.<br />
コマを2つ置いてそのマスの指示通りに動かす(何も書かれていないマスで止まる).<br />
向きが指定されているマスには同時に2つのコマは置けず, そうでないマスには置ける.<br />
移動後に同時に2コマ存在することになる場合はそこで終了.<br />
2つのコマの位置を決めるとき, 動く回数の総和を最大はいくらになるか. 無限に移動できる場合は-1を出力しろ</p>

<h4 id="section-1">解法</h4>

<hr />

<p>移動のルートは無限ループを除いて, &#8216;#&#8217;を根とする木になっている.<br />
根には2つのコマがきてもいいので, その子の部分木を考える.<br />
各部分木の高さhを求めれば最長距離がわかり, その木に2つ置く場合はh-1が2番目に長い距離になる(高さhが2つ以上存在する場合でもそれは途中でぶつかる).<br />
あとはこれを全ての&#8217;#&#8217;を根とする木について調べて高さの最大2つを取ってくれば良い.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code Codeforces/382D.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces 379F New Year Tree]]></title>
    <link href="http://algoogle.hadrori.jp/codeforces/379f/"/>
    <updated>2014-07-09T02:04:27+09:00</updated>
    <id>http://algoogle.hadrori.jp/codeforces/379f</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/problemset/problem/379/F">New Year Tree</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>はじめに根1とその3つの子2~4がある.<br />
q(&lt;=5e5)回の以下のクエリを捌け.</p>

<ul>
  <li>頂点vに2つの頂点を加え, 木の直径を答える</li>
</ul>

<h4 id="section-1">解法</h4>

<hr />

<p>木の直径は一番離れた2点の距離.<br />
初期では頂点2, 3の距離が当てはまる.<br />
頂点を追加するたびにその頂点と, 現在の直径で使われている2点の距離をみる.<br />
もし距離が大きくなるなら頂点を交換する.<br />
距離はLCAを求めればよいのでO(log n)で計算可能.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code Codeforces/379F.cpp %}</p>
]]></content>
  </entry>
  
</feed>
