<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: geometory | Algoogle]]></title>
  <link href="http://algoogle.hadrori.jp/tags/geometory/atom.xml" rel="self"/>
  <link href="http://algoogle.hadrori.jp/"/>
  <updated>2015-07-30T15:13:28+09:00</updated>
  <id>http://algoogle.hadrori.jp/</id>
  <author>
    <name><![CDATA[hadrori]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ 1242 Area of Polygons]]></title>
    <link href="http://algoogle.hadrori.jp/aoj/1242/"/>
    <updated>2015-05-06T12:44:07+09:00</updated>
    <id>http://algoogle.hadrori.jp/aoj/1242</id>
    <content type="html"><![CDATA[<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1242">Area of Polygons</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>頂点が格子点上にある多角形が与えられる．<br />
多角形が通るマスと多角形に含まれるマスの数を答えよ．</p>

<h4 id="section-1">解法</h4>

<hr />

<p>y軸に平行な太さが1マス分の走査線で平面走査する．<br />
各線分から現在見てる区間を切り取って，左側のx座標でソートする．<br />
あとは足される区間と足さない区間が交互にくるので足してやればいい．<br />
y軸に平行な線分は無視．</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code AOJ/1242.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PA 2010 Sweets]]></title>
    <link href="http://algoogle.hadrori.jp/pa/pa2010sweets/"/>
    <updated>2014-11-01T22:15:50+09:00</updated>
    <id>http://algoogle.hadrori.jp/pa/pa2010sweets</id>
    <content type="html"><![CDATA[<p><a href="http://main.edu.pl/en/archive/pa/2010/cuk">Sweets</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>n(&lt;=24)個の箱にそれぞれ{% m %}a_{i}{% em %}個のお菓子がある.<br />
これを3人兄弟Anton, Dmytro, Borysで箱ごとに配りたい.<br />
できるだけ平等に分けるとき最小のAntonとBorysのもらう数の差を求めよ.<br />
ただしそれぞれのもらう数A, D, Bは{% m %} A \geq D \geq B{% em %}を満たさなければならない.</p>

<h4 id="section-1">解法</h4>

<hr />

<p>まずn個の箱を半分ずつ({% m %}n_{0},n_{1}{% em %})に分ける.<br />
これは半分ずつ全列挙することで全体で全列挙するのを抑えるため.<br />
それぞれの集合で3人がもらう数を{% m %}A_{i}, D_{i}, B_{i}{% em %}とする.<br />
{% m %}(A_{i}, D_{i}, B_{i}){% em %}のありうる組を全列挙しておく.<br />
列挙した組の集合をそれぞれ{% m %}K_{0}, K_{1}{% em %}とする.</p>

<p>ここで以下のような変換{% m %}K_{i} \rightarrow K’_{i}{% em %}をする.</p>

<p>{% math %}</p>

<p>K_{0} \rightarrow K’<em>{0}<br />
(A</em>{0}, D_{0}, B_{0}) \in K_{0} \rightarrow (A_{0}-D_{0}, D_{0}-B_{0}) \in K’<em>{0}<br />
<br />
K</em>{1} \rightarrow K’<em>{1}<br />
(A</em>{1}, D_{1}, B_{1}) \in K_{1} \rightarrow (D_{1}-A_{1}, B_{1}-D_{1}) \in K’_{1}\</p>

<p>{% endmath %}</p>

<p>これによって求める最小値は{% m %}K’<em>{0}, K’</em>{1}{% em %}の要素{% m %}(x_{0},y_{0}), (x_{1},y_{1}){% em %}について</p>

<p>{% math %}</p>

<p>(x_{0}+y_{0})-(x_{1}+y_{1})</p>

<p>{% endmath %}</p>

<p>の最小値となる.<br />
ただし{% m %}x_{0}\geq x_{1}, y_{0}\geq y_{1}{% em %}を満たす組のみ.<br />
なぜなら</p>

<p>{% math %}</p>

<p>A_{0}+A_{1} \leq D_{0}+D_{1}<br />
A_{0}-D_{0} \leq D_{1}-A_{1}<br />
<br />
D_{0}+D_{1} \leq B_{0}+B_{1}<br />
D_{0}-B_{0} \leq B_{1}-D_{1}\</p>

<p>{% endmath %}</p>

<p>を満たさなければならないから.</p>

<p>この条件から2次元上の最近点(マンハッタン距離)を求めれば良い.<br />
条件より{% m %}K’<em>{0}{% em %}の点を固定してと考えると, 最も近い{% m %}K’</em>{1}{% em %}の条件を満たす点というのは<br />
それより左下にあるもののうち, x+yが最大になる点とわかる.<br />
これは2つの集合の点を混ぜてyの昇順に見ていけば<br />
{% m %}K’<em>{0}{% em %}の点pのとき, それまでに出てきた{% m %}K’</em>{1}{% em %}の点のうちx座標についてp以下にあって, x+yが最大に点が一番近い.<br />
{% m %}K’_{1}{% em %}の点pのとき, 登場済みリストに入れる. ただしx座標についてそれ以降の点でx+yの値ががp以下のものは選ばれることが無い(もしくはそれを選ぶ必要がない)ので予め削除する.</p>

<p>2つ目の操作から登場済みリストはxについて単調増加であり, またx+yについて単調非減少になる.<br />
これの性質を利用することで1つ目の操作はx座標についてp以下のもののうち一番近いものを2分探索で選べばよく, 2つ目の操作はx座標についてp以上かつx+yについてp以下の点の区間を2分探索で求め削除することができる.</p>

<p>計算量は列挙に{% m %}O(3^{n/2}) = O(\sqrt{3}^{n}){% em %}, 各操作に{% m %}O(\log \sqrt{3}^{n}){% em %}となる.<br />
よって全体では{% m %}O(\sqrt(3)^{n}n) = O(1.74^{n}){% em %}となりなんとか間に合う.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code PA/2010/sweets.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JOI 春合宿 2008 Ruins]]></title>
    <link href="http://algoogle.hadrori.jp/joi/sc2008ruins/"/>
    <updated>2014-09-04T15:59:01+09:00</updated>
    <id>http://algoogle.hadrori.jp/joi/sc2008ruins</id>
    <content type="html"><![CDATA[<p><a href="http://joisc2008.contest.atcoder.jp/tasks/joisc2008_ruins">Ruins</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>n個の点が与えられる.<br />
その点のうちいくつかを使って凸多角形を作る. 作れる凸多角形のうち最大の頂点数を求めよ</p>

<h4 id="section-1">解法</h4>

<hr />

<p>頂点を一つ決める.<br />
その頂点とその左側にある点だけを使って凸多角形を作るDPをする.<br />
dp[i][j] := 最後に辺ijを使った時の最大の頂点数</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code JOI/2008/Ruins.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JOI 春合宿 2008 Nightman]]></title>
    <link href="http://algoogle.hadrori.jp/joi/sc2008nightman/"/>
    <updated>2014-09-04T15:33:35+09:00</updated>
    <id>http://algoogle.hadrori.jp/joi/sc2008nightman</id>
    <content type="html"><![CDATA[<p><a href="http://joisc2008.contest.atcoder.jp/tasks/joisc2008_nightman">Nightman</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>長方形の建物がいくつかあり, いくつかの危険物と何人かの警備員の位置が与えられる.<br />
危険物まで一番近い警備員の建物の内側を通らない最短距離往復分の総和を求めよ.</p>

<h4 id="section-1">解法</h4>

<hr />

<p>長方形の各頂点と危険物と警備員総てを直線で結んで長方形と交差しなかったら辺を張る.<br />
あとはDijkstraすればよい.<br />
長方形の辺上は通れるので交差判定を避けるために少し内側にepsをとる.</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code JOI/2008/Nightman.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JOI 春合宿 2008 Belt]]></title>
    <link href="http://algoogle.hadrori.jp/joi/sc2008belt/"/>
    <updated>2014-09-04T03:10:07+09:00</updated>
    <id>http://algoogle.hadrori.jp/joi/sc2008belt</id>
    <content type="html"><![CDATA[<p><a href="http://joisc2008.contest.atcoder.jp/tasks/joisc2008_belt">Belt</a></p>

<h4 id="section">問題概要</h4>

<hr />

<p>平面上に直線を引いたときに, その直線から距離d以内に存在する点の数を最大化しろ</p>

<h4 id="section-1">解法</h4>

<hr />

<p>1点を固定して中心と考える.<br />
その点を通る直線から左右どちらかに幅2dをとって360度回してやって, 各イベント点でいくつ中に入ってきてるかカウントしてやれば良い.</p>

<p>はじめ帯がx軸から上に幅2dとった状態からスタートするとする.<br />
イベントは点が帯に入るときと出るときで, 点の偏角をth, 原点からの距離をrとすると</p>

<ul>
  <li>th-asin(d/r) : 帯に入る</li>
  <li>th : 帯から出る</li>
  <li>th+pi : 帯に入る</li>
  <li>th+pi+asin(d/r) : 帯から出る</li>
</ul>

<p>の4つが考えられる.<br />
またrがd以下の場合帯から出られない部分があるので</p>

<ul>
  <li>th+pi : 帯に入る</li>
  <li>th : 帯から出る</li>
</ul>

<p>の2つだけになる.<br />
あとははじめから帯に入っている場合に注意してイベント(偏角)順にソートして順番に見ていけばよい</p>

<h4 id="section-2">コード</h4>

<hr />

<p>{% include_code JOI/2008/Belt.cpp %}</p>
]]></content>
  </entry>
  
</feed>
